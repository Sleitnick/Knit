[{"title":"KnitServer","type":0,"sectionRef":"#","url":"api/KnitServer","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#types","content":" "},{"title":"Service","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Service","content":"&lt;/&gt; interface Service { Name: string Client: ServiceClient KnitComm: Comm [any]: any }   "},{"title":"ServiceClient","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#ServiceClient","content":"&lt;/&gt; interface ServiceClient { Server: Service [any]: any }   "},{"title":"ServiceDef","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#ServiceDef","content":"&lt;/&gt; interface ServiceDef { Name: string Client: table? [any]: any } Used to define a service when creating it in CreateService. "},{"title":"Properties","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#properties","content":" "},{"title":"Util","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitServer.Util: Folder References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#functions","content":" "},{"title":"AddServices","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#AddServices","content":"&lt;/&gt; KnitServer.AddServices(parent: Instance) → services: {Service} Requires all the modules that are children of the given parent. This is an easy way to quickly load all services that might be in a folder. Knit.AddServices(somewhere.Services)   "},{"title":"AddServicesDeep","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#AddServicesDeep","content":"&lt;/&gt; KnitServer.AddServicesDeep(parent: Instance) → services: {Service} Requires all the modules that are descendants of the given parent.  "},{"title":"CreateService","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#CreateService","content":"&lt;/&gt; KnitServer.CreateService(serviceDefinition: ServiceDef) → Service Constructs a new service. caution Services must be created before calling Knit.Start(). -- Create a service local MyService = Knit.CreateService { Name = &quot;MyService&quot;; Client = {}; } -- Expose a ToAllCaps remote function to the clients function MyService.Client:ToAllCaps(player, msg) return msg:upper() end -- Knit will call KnitStart after all services have been initialized function MyService:KnitStart() print(&quot;MyService started&quot;) end -- Knit will call KnitInit when Knit is first started function MyService:KnitInit() print(&quot;MyService initialize&quot;) end   "},{"title":"CreateSignal","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#CreateSignal","content":"&lt;/&gt; KnitServer.CreateSignal() → SIGNAL_MARKER Returns a marker that will transform the current key into a RemoteSignal once the service is created. Should only be called within the Client table of a service. See RemoteSignal documentation for more info. local MyService = Knit.CreateService { Name = &quot;MyService&quot;; Client = { MySignal = Knit.CreateSignal(); -- Create the signal marker } } -- Connect to the signal: MyService.Client.MySignal:Connect(function(player, ...) end)   "},{"title":"GetService","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#GetService","content":"&lt;/&gt; KnitServer.GetService(serviceName: string) → Service Gets the service by name. Throws an error if the service is not found.  "},{"title":"OnStart","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#OnStart","content":"&lt;/&gt; KnitServer.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit services but is not the script that called Start. Knit.OnStart():andThen(function() local MyService = Knit.Services.MyService MyService:DoSomething() end):catch(warn)   "},{"title":"Start","type":1,"pageTitle":"KnitServer","url":"api/KnitServer#Start","content":"&lt;/&gt; KnitServer.Start() → Promise Starts Knit. Should only be called once. caution Be sure that all services have been created before calling Start. Services cannot be added later. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)  "},{"title":"KnitClient","type":0,"sectionRef":"#","url":"api/KnitClient","content":"","keywords":""},{"title":"Types","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#types","content":" "},{"title":"Controller","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Controller","content":"&lt;/&gt; interface Controller { Name: string [any]: any }   "},{"title":"ControllerDef","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#ControllerDef","content":"&lt;/&gt; interface ControllerDef { Name: string [any]: any }   "},{"title":"KnitOptions","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#KnitOptions","content":"&lt;/&gt; interface KnitOptions { ServicePromises: boolean-- Defaults to true } ServicePromises defaults to true and indicates if service methods use promises.  "},{"title":"Service","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Service","content":"&lt;/&gt; interface Service { [any]: any }  "},{"title":"Properties","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#properties","content":" "},{"title":"Player","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Player","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Player: Player Reference to the LocalPlayer.  "},{"title":"Util","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Util","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; KnitClient.Util: Folder References the Util folder. Should only be accessed when using Knit as a standalone module. If using Knit from Wally, modules should just be pulled in via Wally instead of relying on Knit's Util folder, as this folder only contains what is necessary for Knit to run in Wally mode. "},{"title":"Functions","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#functions","content":" "},{"title":"AddControllers","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#AddControllers","content":"&lt;/&gt; KnitClient.AddControllers(parent: Instance) → controllers: {Controller} Requires all the modules that are children of the given parent. This is an easy way to quickly load all controllers that might be in a folder. Knit.AddControllers(somewhere.Controllers)   "},{"title":"AddControllersDeep","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#AddControllersDeep","content":"&lt;/&gt; KnitClient.AddControllersDeep(parent: Instance) → controllers: {Controller} Requires all the modules that are descendants of the given parent.  "},{"title":"CreateController","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#CreateController","content":"&lt;/&gt; KnitClient.CreateController(controllerDefinition: ControllerDef) → Controller Creates a new controller.  "},{"title":"GetController","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#GetController","content":"&lt;/&gt; KnitClient.GetController(controllerName: string) → Controller? Gets the controller by name. Throws an error if the controller is not found.  "},{"title":"GetService","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#GetService","content":"&lt;/&gt; KnitClient.GetService(serviceName: string) → Service? Returns a Service object which is a reflection of the remote objects within the Client table of the given service. Returns nil if the service is not found. caution Services are only exposed to the client if the service has remote-based content in the Client table. If not, the service will not be visible to the client. KnitClient.GetService will only work on services that expose remote-based content on their Client tables.  "},{"title":"OnStart","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#OnStart","content":"&lt;/&gt; KnitClient.OnStart() → Promise Returns a promise that is resolved once Knit has started. This is useful for any code that needs to tie into Knit controllers but is not the script that called Start. Knit.OnStart():andThen(function() local MyController = Knit.GetController(&quot;MyController&quot;) MyController:DoSomething() end):catch(warn)   "},{"title":"Start","type":1,"pageTitle":"KnitClient","url":"api/KnitClient#Start","content":"&lt;/&gt; KnitClient.Start(options: KnitOptions?) → Promise Starts Knit. Should only be called once per client. Knit.Start():andThen(function() print(&quot;Knit started!&quot;) end):catch(warn) By default, service methods exposed to the client will return promises. To change this behavior, set the ServicePromises option to false: Knit.Start({ServicePromises = false}):andThen(function() print(&quot;Knit started!&quot;) end):catch(warn)  "},{"title":"Controllers","type":0,"sectionRef":"#","url":"docs/controllers","content":"","keywords":""},{"title":"Controllers Defined","type":1,"pageTitle":"Controllers","url":"docs/controllers#controllers-defined","content":"Controllers are singleton provider objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. For the sake of example, we will develop a CameraController. "},{"title":"Creating Controllers","type":1,"pageTitle":"Controllers","url":"docs/controllers#creating-controllers","content":"In its simplest form, a controller can be created like so: local CameraController = Knit.CreateController { Name = &quot;CameraController&quot; } return CameraController Copy The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = &quot;CameraController&quot;). The last line (return CameraController) assumes this code is written in a ModuleScript, which is best practice for containing controllers. "},{"title":"Adding Methods","type":1,"pageTitle":"Controllers","url":"docs/controllers#adding-methods","content":"Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. function CameraController:LockTo(part) -- TODO: Lock cameraend function CameraController:Unlock() -- TODO: Unlockend Copy "},{"title":"Adding Properties","type":1,"pageTitle":"Controllers","url":"docs/controllers#adding-properties","content":"Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: CameraController.Distance = 20CameraController.Locked = false Copy "},{"title":"Adding Basic Behavior","type":1,"pageTitle":"Controllers","url":"docs/controllers#adding-basic-behavior","content":"Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. function CameraController:LockTo(part) local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance)end function CameraController:Unlock() local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Customend Copy "},{"title":"More Behavior","type":1,"pageTitle":"Controllers","url":"docs/controllers#more-behavior","content":"Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. local RunService = game:GetService(&quot;RunService&quot;) CameraController.RenderName = &quot;CustomCamRender&quot;CameraController.Priority = Enum.RenderPriority.Camera.Value function CameraController:LockTo(part) if (self.Locked) then return end -- Stop if already locked local cam = workspace.CurrentCamera self.Locked = true cam.CameraType = Enum.CameraType.Scriptable -- Bind to RenderStep: RunService:BindToRenderStep(self.RenderName, self.Priority, function() cam.CFrame = part.CFrame * CFrame.new(0, 0, self.Distance) end)end function CameraController:Unlock() if (not self.Locked) then return end -- Stop if already unlocked local cam = workspace.CurrentCamera self.Locked = false cam.CameraType = Enum.CameraType.Custom -- Unbind: RunService:UnbindFromRenderStep(self.RenderName)end Copy "},{"title":"Events","type":1,"pageTitle":"Controllers","url":"docs/controllers#events","content":"What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. local Signal = require(Knit.Util.Signal) CameraController.LockedChanged = Signal.new() function CameraController:LockTo(part) -- Other code... self.LockedChanged:Fire(true)end function CameraController:Unlock() -- Other code... self.LockedChanged:Fire(false)end Copy Other code could then listen in for that event: -- Somewhere else on the clientlocal CameraController = Knit.Controllers.CameraController CameraController.LockedChanged:Connect(function(isLocked) print(isLocked and &quot;Camera is now locked&quot; or &quot;Camera was unlocked&quot;)end) Copy "},{"title":"Server Communication","type":1,"pageTitle":"Controllers","url":"docs/controllers#server-communication","content":"Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: function CameraController:KnitStart() local SomeService = Knit.GetService(&quot;SomeService&quot;) SomeService:DoSomething() SomeService.SomeEvent:Connect(function(...) end) SomeService.AnotherEvent:Fire(&quot;Some data&quot;)end Copy No client table forces server-only mode If the Client table is omitted from the service, the service will be interpreted as server-side only. This means that the client will not be able to access the service using Knit.GetService on the client if there is no Client table present. "},{"title":"KnitInit and KnitStart","type":1,"pageTitle":"Controllers","url":"docs/controllers#knitinit-and-knitstart","content":"The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model. These methods can be added just like any other method: function CameraController:KnitStart() print(&quot;CameraController KnitStart called&quot;)end function CameraController:KnitInit() print(&quot;CameraController KnitInit called&quot;)end Copy "},{"title":"Examples","type":0,"sectionRef":"#","url":"docs/examples","content":"","keywords":""},{"title":"Start All Services","type":1,"pageTitle":"Examples","url":"docs/examples#start-all-services","content":"A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script]Services [Folder] MyService [Module]AnotherService [Module]HelloService [Module] We can write our KnitRuntime script as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services:for _,v in ipairs(script.Parent.Services:GetDescendants()) do if (v:IsA(&quot;ModuleScript&quot;)) then require(v) endend Knit.Start():catch(warn) Copy Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load all services within 'Services':Knit.AddServices(script.Parent.Services) -- Load all services (the Deep version scans all descendants of the passed instance):Knit.AddServicesDeep(script.Parent.OtherServices) Knit.Start():catch(warn) Copy tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function.  "},{"title":"Expose a Collection of Modules","type":1,"pageTitle":"Examples","url":"docs/examples#expose-a-collection-of-modules","content":"Like Knit.Util, we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules, we can expose this within our main runtime script: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Expose our MyModules folder:Knit.MyModules = game:GetService(&quot;ReplicatedStorage&quot;).MyModules -- Load services/controllers Knit.Start() Copy We can then use these modules elsewhere. For instance: local SomeModule = require(Knit.MyModules.SomeModule) Copy "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/gettingstarted","content":"","keywords":""},{"title":"Install","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#install","content":"Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library.Place Knit directly within ReplicatedStorage. Rojo/Wally workflow: Add Knit to your wally.toml dependency list (e.g. Knit = &quot;sleitnick/knit@1.1.0-rc.2&quot;) Require Knit like any other module grabbed from Wally Wally Not familiar with Wally? Wally is a package manager (like NPM) for the Roblox ecosystem. To get started, check out the Wally repository. "},{"title":"Basic Usage","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#basic-usage","content":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Knit.Start():catch(warn)-- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function-- You could also chain 'await()' to the end to yield until the whole sequence is completed:-- Knit.Start():catch(warn):await() Copy That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. "},{"title":"A Simple Service","type":1,"pageTitle":"Getting Started","url":"docs/gettingstarted#a-simple-service","content":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Create the service:local MoneyService = Knit.CreateService { Name = &quot;MoneyService&quot;;} -- Add some methods to the service: function MoneyService:GetMoney(player) -- Do some sort of data fetch local money = someDataStore:GetAsync(&quot;money&quot;) return moneyend function MoneyService:GiveMoney(player, amount) -- Do some sort of data fetch local money = self:GetMoney(player) money += amount someDataStore:SetAsync(&quot;money&quot;, money)end Knit.Start():catch(warn) Copy note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: -- Money service on the server...function MoneyService.Client:GetMoney(player) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self.Server:GetMoney(player)end... Copy We can write client-side code to fetch money from the service: -- Client-side codelocal Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit)Knit.Start():catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) MoneyService:GetMoney():andThen(function(money) print(money)end) -- Don't want to use promises? When you start Knit on the client,-- set the ServicePromises option to false: Copy Turn Off Promises Don't want to use promises when the client calls a service method? Set the ServicePromises option to false when you start Knit on the client: Knit.Start({ServicePromises = false}):catch(warn):await() local MoneyService = Knit.GetService(&quot;MoneyService&quot;) local money = MoneyService:GetMoney() Copy Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services. "},{"title":"Execution Model","type":0,"sectionRef":"#","url":"docs/executionmodel","content":"","keywords":""},{"title":"Lifecycle","type":1,"pageTitle":"Execution Model","url":"docs/executionmodel#lifecycle","content":"The execution model of Knit defines the flow of operations and lifecycle of Knit. Require the Knit moduleCreate services or controllersCall Knit.Start(), which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finishAll KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves  On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) -- Load services or controllers here Knit.Start():catch(warn) Copy Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). caution Services and controllers cannot be created after Knit.Start() has been called. "},{"title":"Catching KnitInit Errors","type":1,"pageTitle":"Execution Model","url":"docs/executionmodel#catching-knitinit-errors","content":"Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: local success, err = Knit.Start():await()if (not success) then -- Handle error error(tostring(err))end Copy Knit.Start():catch(function(err) -- Handle error warn(tostring(err))end) Copy "},{"title":"Best Practices","type":1,"pageTitle":"Execution Model","url":"docs/executionmodel#best-practices","content":"Only one Script on the server should manage loading services and starting KnitOnly one LocalScript on the client should manage loading controllers and starting KnitSplit up services and controllers into their own modulesServices should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the clientCode within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possibleEvents and methods should never be added to a service's Client table after Knit.Start() has been calledAs shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup. "},{"title":"About","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Why Choose Knit?","type":1,"pageTitle":"About","url":"docs/intro#why-choose-knit","content":""},{"title":"Structure (Where you want it)","type":1,"pageTitle":"About","url":"docs/intro#structure-where-you-want-it","content":"At the core of Knit are services and controllers, which are just singleton classes that can be easily created. These providers give basic structure to a game. However, not all code is required to live within this sytem. External code in your game can still tie into Knit's services and controllers. "},{"title":"Server / Client Bridge","type":1,"pageTitle":"About","url":"docs/intro#server--client-bridge","content":"Knit bridges the server/client boundary through declarative code that is easy to set up and easy to use. No need to manually create RemoteEvents and RemoteFunctions anymore. Knit handles the core networking for you. "},{"title":"Framework / Library Hybrid","type":1,"pageTitle":"About","url":"docs/intro#framework--library-hybrid","content":"While advertised as a game framework, Knit straddles the line between a framework and a library. While Knit provides optional structure using services and controllers, developers can choose if and how these structures are utilized. Developers are also responsible for creating the runtime scripts for Knit (i.e. bootstrapping), which allows easy extensibility of the framework. "},{"title":"For Everyone","type":1,"pageTitle":"About","url":"docs/intro#for-everyone","content":"Knit is designed to be used by everyone, from professional game studios to someone just diving into Roblox development. For the pros, Knit is available via Wally and can be synced into Studio with Rojo. For the beginners, Knit is available as a standalone model that can be drag-and-dropped into Studio. "},{"title":"Widely Used","type":1,"pageTitle":"About","url":"docs/intro#widely-used","content":"Knit is battle-tested in the Roblox ecosystem, as it has been used by many games across the platform. "},{"title":"Util","type":0,"sectionRef":"#","url":"docs/util","content":"","keywords":""},{"title":"Knit via Wally","type":1,"pageTitle":"Util","url":"docs/util#knit-via-wally","content":"When installing Knit with Wally, developers should pull in utility modules via Wally as required. Knit's utility modules are significantly slimmed down in the Wally release. "},{"title":"Knit via ModuleScript","type":1,"pageTitle":"Util","url":"docs/util#knit-via-modulescript","content":"Knit comes with a few utility modules. If Knit is being used from the packaged ModuleScript, then the best way to access these modules is via require(Knit.Util.PACKAGE). The following modules are available: Knit.Util.CommKnit.Util.ComponentKnit.Util.EnumListKnit.Util.OptionKnit.Util.SignalKnit.Util.TableUtilKnit.Util.TimerKnit.Util.TroveKnit.Util.Promise Below is an example of the Signal class being used in a service: local Signal = require(Knit.Util.Signal) local MyService = Knit.CreateService { Name = &quot;MyService&quot;; SomeSignal = Signal.new();} Copy "},{"title":"Services","type":0,"sectionRef":"#","url":"docs/services","content":"","keywords":""},{"title":"Services Defined","type":1,"pageTitle":"Services","url":"docs/services#services-defined","content":"Services are singleton provider objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. "},{"title":"Creating Services","type":1,"pageTitle":"Services","url":"docs/services#creating-services","content":"In its simplest form, a service can be created like so: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;, Client = {} } return PointsService Copy Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. No client table forces server-only mode If the Client table is omitted, the service will be interpreted as server-side only. This means that the client will not be able to access this service using Knit.GetService on the client. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = &quot;PointsService&quot;). The last line (return PointsService) assumes this code is written in a ModuleScript, which is best practice for containing services. "},{"title":"Adding methods","type":1,"pageTitle":"Services","url":"docs/services#adding-methods","content":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. function PointsService:AddPoints(player, amount) -- TODO: add pointsend function PointsService:GetPoints(player) return 0end Copy "},{"title":"Adding properties","type":1,"pageTitle":"Services","url":"docs/services#adding-properties","content":"Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: PointsService.PointsPerPlayer = {} Copy "},{"title":"Using methods and properties","type":1,"pageTitle":"Services","url":"docs/services#using-methods-and-properties","content":"Now we can change our AddPoints() and GetPoints() methods to use this field. PointsService.PointsPerPlayer = {} function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) -- Current amount of points points += amount -- Add points self.PointsPerPlayer[player] = points -- Store pointsend function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return points or 0 -- Return 0 if no points found for playerend Copy "},{"title":"Using events","type":1,"pageTitle":"Services","url":"docs/services#using-events","content":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: -- Load the Signal module and create PointsChanged signal:local Signal = require(Knit.Util.Signal)PointsService.PointsChanged = Signal.new() -- Modify AddPoints:function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points -- Fire event signal, as long as we actually changed the points: if (amount ~= 0) then self.PointsChanged:Fire(player, points) endend Copy Another service could then listen for the changes on that event: function SomeOtherService:KnitStart() local PointsService = Knit.Services.PointsService PointsService.PointsChanged:Connect(function(player, points) print(&quot;Points changed for &quot; .. player.Name .. &quot;:&quot;, points) end)end Copy "},{"title":"KnitInit and KnitStart","type":1,"pageTitle":"Services","url":"docs/services#knitinit-and-knitstart","content":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up your service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. "},{"title":"Cleaning Up Unused Memory","type":1,"pageTitle":"Services","url":"docs/services#cleaning-up-unused-memory","content":"Alright, back to our PointsService! We have a problem... We have created a memory leak! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: function PointsService:KnitInit() game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) -- Clear out the data for hte player when the player leaves: self.PointsPerPlayer[player] = nil end)end Copy While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. "},{"title":"Client Communication","type":1,"pageTitle":"Services","url":"docs/services#client-communication","content":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. "},{"title":"Methods","type":1,"pageTitle":"Services","url":"docs/services#methods","content":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: function PointsService.Client:GetPoints(player) -- We can just call our other method from here: return self.Server:GetPoints(player)end Copy This creates a client-exposed method called GetPoints. Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: -- From a LocalScriptlocal Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;)PointsService:GetPoints():andThen(function(points) print(&quot;Points for myself:&quot;, points)end) Copy "},{"title":"Signals (Server-to-Client)","type":1,"pageTitle":"Services","url":"docs/services#signals-server-to-client","content":"We should also create a signal that we can fire events for the clients when their points change. We can use Knit:CreateSignal() to indicate we want a signal created for the service. local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;; Client = { PointsChanged = Knit.CreateSignal(); -- Create the signal };} Copy Remote Signal See the RemoteSignal documentation for more info on how to use the RemoteSignal object. Under the hood, Knit is using the Comm module, which is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) -- Fire the client signal: self.Client.PointsChanged:Fire(player, points) endend Copy And from the client, we can listen for an event on the signal: -- From a LocalScriptlocal Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) PointsService.PointsChanged:Connect(function(points) print(&quot;Points for myself now:&quot;, points)end) Copy "},{"title":"Signals (Client-to-Server)","type":1,"pageTitle":"Services","url":"docs/services#signals-client-to-server","content":"Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;; Client = { PointsChanged = Knit.CreateSignal(); GiveMePoints = Knit.CreateSignal(); -- Create the new signal };} Copy Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: function PointsService:KnitInit() local rng = Random.new() -- Listen for the client to fire this signal, then give random points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- ...other code for cleaning up player data hereend Copy From the client, we can fire the signal like so: -- From a LocalScriptlocal Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local PointsService = Knit.GetService(&quot;PointsService&quot;) -- Fire the signal:PointsService.GiveMePoints:Fire() Copy Client Remote Signal See the ClientRemoteSignal documentation for more info on how to use the ClientRemoteSignal object.  "},{"title":"Full Example","type":1,"pageTitle":"Services","url":"docs/services#full-example","content":""},{"title":"PointsService","type":1,"pageTitle":"Services","url":"docs/services#pointsservice","content":"At the end of this tutorial, we should have a PointsService that looks something like this: local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit)local Signal = require(Knit.Util.Signal) local PointsService = Knit.CreateService { Name = &quot;PointsService&quot;; -- Define some properties: PointsPerPlayer = {}; PointsChanged = Signal.new(); Client = { -- Expose signals to the client: PointsChanged = Knit.CreateSignal(); GiveMePoints = Knit.CreateSignal(); };} -- Client exposed GetPoints method:function PointsService.Client:GetPoints(player) return self.Server:GetPoints(player)end -- Add Points:function PointsService:AddPoints(player, amount) local points = self:GetPoints(player) points += amount self.PointsPerPlayer[player] = points if amount ~= 0 then self.PointsChanged:Fire(player, points) self.Client.PointsChanged:Fire(player, points) endend -- Get Points:function PointsService:GetPoints(player) local points = self.PointsPerPlayer[player] return points or 0end -- Initializefunction PointsService:KnitInit() local rng = Random.new() -- Give player random amount of points: self.Client.GiveMePoints:Connect(function(player) local points = rng:NextInteger(0, 10) self:AddPoints(player, points) print(&quot;Gave &quot; .. player.Name .. &quot; &quot; .. points .. &quot; points&quot;) end) -- Clean up data when player leaves: game:GetService(&quot;Players&quot;).PlayerRemoving:Connect(function(player) self.PointsPerPlayer[player] = nil end) end return PointsService Copy "},{"title":"Client Consumer","type":1,"pageTitle":"Services","url":"docs/services#client-consumer","content":"Example of client-side LocalScript consuming the PointsService: -- From a LocalScriptlocal Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit)Knit.Start():catch(warn):await() local PointsService = Knit.GetService(&quot;PointsService&quot;) local function PointsChanged(points) print(&quot;My points:&quot;, points)end -- Get points and listen for changes:PointsService:GetPoints():andThen(PointsChanged)PointsService.PointsChanged:Connect(PointsChanged) -- Ask server to give points randomly:PointsService.GiveMePoints:Fire() Copy "},{"title":"VS Code Snippets","type":0,"sectionRef":"#","url":"docs/vscodesnippets","content":"","keywords":""},{"title":"Using Snippets","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#using-snippets","content":"Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -&gt; Preferences -&gt; User SnippetsType in and select lua.jsonWithin the {} braces, include any or all of the snippets belowSave the fileWithin your actual source files, start typing a prefix (e.g. &quot;knit&quot;) and select the autocompleted snippet to paste it inDepending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service)  "},{"title":"Knit Snippets","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-snippets","content":"Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage. "},{"title":"Knit","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit","content":"Include a require statement for Knit. Snippet &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(game:GetService(\\&quot;ReplicatedStorage\\&quot;).Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot;} Copy Code Result local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) Copy  "},{"title":"Service","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#service","content":"Reference a Roblox service. Snippet &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot;} Copy Code Result local HttpService = game:GetService(&quot;HttpService&quot;) Copy  "},{"title":"Knit Service","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-service","content":"Reference Knit, create a service, and return the service. Snippet &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(game:GetService(\\&quot;ReplicatedStorage\\&quot;).Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;;&quot;, &quot;\\tClient = {};&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot;} Copy Code Result local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local MyService = Knit.CreateService { Name = &quot;MyService&quot;; Client = {};} function MyService:KnitStart()end function MyService:KnitInit()end return MyService Copy  "},{"title":"Knit Controller","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-controller","content":"Reference Knit, create a controller, and return the controller. Snippet &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(game:GetService(\\&quot;ReplicatedStorage\\&quot;).Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot;} Copy Code Result local Knit = require(game:GetService(&quot;ReplicatedStorage&quot;).Packages.Knit) local MyController = Knit.CreateController { Name = &quot;MyController&quot;;} function MyController:KnitStart()end function MyController:KnitInit()end return MyController Copy  "},{"title":"Knit Require","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#knit-require","content":"Require a module within Knit. Snippet &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot;} Copy Code Result local Signal = require(Knit.Util.Signal) Copy  "},{"title":"Lua Class","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#lua-class","content":"A standard Lua class. Snippet &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot;} Copy Code Result local MyClass = {}MyClass.__index = MyClass function MyClass.new() local self = setmetatable({}, MyClass) return selfend function MyClass:Destroy() end return MyClass Copy  "},{"title":"All","type":1,"pageTitle":"VS Code Snippets","url":"docs/vscodesnippets#all","content":"All the above snippets together. All Snippets { &quot;Service&quot;: { &quot;prefix&quot;: [&quot;service&quot;], &quot;body&quot;: [&quot;local ${0:Name}Service = game:GetService(\\&quot;${0:Name}Service\\&quot;)&quot;], &quot;description&quot;: &quot;Roblox Service&quot; }, &quot;Class&quot;: { &quot;prefix&quot;: [&quot;class&quot;], &quot;body&quot;: [ &quot;local ${0:$TM_FILENAME_BASE} = {}&quot;, &quot;${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}.new()&quot;, &quot;\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})&quot;, &quot;\\treturn self&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:Destroy()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Lua Class&quot; }, &quot;Knit&quot;: { &quot;prefix&quot;: [&quot;knit&quot;], &quot;body&quot;: [&quot;local Knit = require(game:GetService(\\&quot;ReplicatedStorage\\&quot;).Packages.Knit)&quot;], &quot;description&quot;: &quot;Require the Knit module&quot; }, &quot;Knit Service&quot;: { &quot;prefix&quot;: [&quot;knitservice&quot;], &quot;body&quot;: [ &quot;local Knit = require(game:GetService(\\&quot;ReplicatedStorage\\&quot;).Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateService {&quot;, &quot;\\tName = \\&quot;${0:$TM_FILENAME_BASE}\\&quot;;&quot;, &quot;\\tClient = {};&quot;, &quot;}&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Service template&quot; }, &quot;Knit Controller&quot;: { &quot;prefix&quot;: [&quot;knitcontroller&quot;], &quot;body&quot;: [ &quot;local Knit = require(game:GetService(\\&quot;ReplicatedStorage\\&quot;).Packages.Knit)&quot;, &quot;&quot;, &quot;local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\&quot;${0:$TM_FILENAME_BASE}\\&quot; }&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitStart()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;function ${0:$TM_FILENAME_BASE}:KnitInit()&quot;, &quot;\\t&quot;, &quot;end&quot;, &quot;&quot;, &quot;&quot;, &quot;return ${0:$TM_FILENAME_BASE}&quot;, &quot;&quot; ], &quot;description&quot;: &quot;Knit Controller template&quot; }, &quot;Knit Require&quot;: { &quot;prefix&quot;: [&quot;knitrequire&quot;], &quot;body&quot;: [&quot;local ${1:Name} = require(Knit.${2:Util}.${1:Name})&quot;], &quot;description&quot;: &quot;Knit Require template&quot; } } Copy "}]