{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Knit \u00b6 A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. See the Getting Started guide to start using Knit.","title":"Home"},{"location":"#knit","text":"A lightweight framework for Roblox that simplifies communication between core parts of your game and seamlessly bridges the gap between the server and the client. See the Getting Started guide to start using Knit.","title":"Knit"},{"location":"controllers/","text":"Controllers Defined \u00b6 Controllers are singleton objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. A game might have many controllers. They serve as a core structure of the client within Knit. For the sake of example, we will develop a CameraController. For full API documentation, visit the Knit API page. Creating Controllers \u00b6 In its simplest form, a controller can be created like so: 1 2 3 local CameraController = Knit . CreateController { Name = \"CameraController\" } return CameraController The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = \"CameraController\" ). The last line ( return CameraController ) assumes this code is written in a ModuleScript, which is best practice for containing controllers. Adding methods \u00b6 Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. 1 2 3 4 5 6 7 function CameraController : LockTo ( part ) -- TODO: Lock camera end function CameraController : Unlock () -- TODO: Unlock end Adding properties \u00b6 Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: 1 2 CameraController . Distance = 20 CameraController . Locked = false Adding Basic Behavior \u00b6 Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. 1 2 3 4 5 6 7 8 9 10 11 12 function CameraController : LockTo ( part ) local cam = workspace . CurrentCamera self . Locked = true cam . CameraType = Enum . CameraType . Scriptable cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end function CameraController : Unlock () local cam = workspace . CurrentCamera self . Locked = false cam . CameraType = Enum . CameraType . Custom end More Behavior \u00b6 Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 CameraController . RenderName = \"CustomCamRender\" CameraController . Priority = Enum . RenderPriority . Camera . Value function CameraController : LockTo ( part ) if ( self . Locked ) then return end -- Stop if already locked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = true cam . CameraType = Enum . CameraType . Scriptable -- Bind to RenderStep: runService : BindToRenderStep ( self . RenderName , self . Priority , function () cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end ) end function CameraController : Unlock () if ( not self . Locked ) then return end -- Stop if already unlocked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = false cam . CameraType = Enum . CameraType . Custom -- Unbind: runService : UnbindFromRenderStep ( self . RenderName ) end Events \u00b6 What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. 1 2 3 4 5 6 7 8 9 10 11 12 13 local Signal = require ( Knit . Util . Signal ) CameraController . LockedChanged = Signal . new () function CameraController : LockTo ( part ) -- Other code... self . LockedChanged : Fire ( true ) end function CameraController : Unlock () -- Other code... self . LockedChanged : Fire ( false ) end Other code could then listen in for that event: 1 2 3 4 5 6 -- Somewhere else on the client local CameraController = Knit . Controllers . CameraController CameraController . LockedChanged : Connect ( function ( isLocked ) print ( isLocked and \"Camera is now locked\" or \"Camera was unlocked\" ) end ) Server Communication \u00b6 Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: 1 2 3 4 5 6 function CameraController : KnitStart () local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () SomeService . SomeEvent : Connect ( function (...) end ) SomeService . AnotherEvent : Fire ( \"Some data\" ) end KnitInit and KnitStart \u00b6 The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model . These methods can be added just like any other method: 1 2 3 4 5 6 7 function CameraController : KnitStart () print ( \"CameraController KnitStart called\" ) end function CameraController : KnitInit () print ( \"CameraController KnitInit called\" ) end","title":"Controllers"},{"location":"controllers/#controllers-defined","text":"Controllers are singleton objects that serve a specific purpose on the client. For instance, a game might have a CameraController, which manages a custom in-game camera for the player. A controller is essentially the client-side equivalent of a service on the server. A game might have many controllers. They serve as a core structure of the client within Knit. For the sake of example, we will develop a CameraController. For full API documentation, visit the Knit API page.","title":"Controllers Defined"},{"location":"controllers/#creating-controllers","text":"In its simplest form, a controller can be created like so: 1 2 3 local CameraController = Knit . CreateController { Name = \"CameraController\" } return CameraController The Name field is required. The name is how code outside of your controller will find it. This name must be unique from all other controllers. It is best practice to name your variable the same as the controller (e.g. local CameraController matches Name = \"CameraController\" ). The last line ( return CameraController ) assumes this code is written in a ModuleScript, which is best practice for containing controllers.","title":"Creating Controllers"},{"location":"controllers/#adding-methods","text":"Controllers are just simple tables at the end of the day. As such, it is very easy to add methods to controllers. 1 2 3 4 5 6 7 function CameraController : LockTo ( part ) -- TODO: Lock camera end function CameraController : Unlock () -- TODO: Unlock end","title":"Adding methods"},{"location":"controllers/#adding-properties","text":"Again, controllers are just tables. We can simply add in properties as we want. Let's add a property to describe how far away our camera should be from the part we lock onto, and another to describe if the camera is currently locked: 1 2 CameraController . Distance = 20 CameraController . Locked = false","title":"Adding properties"},{"location":"controllers/#adding-basic-behavior","text":"Let's add some basic behavior to our controller. When the camera is locked, we should set the CurrentCamera's CameraType to Scriptable, and set the CFrame to the part. When unlocked, we should set the CameraType back to Custom. We will also utilize the Locked property so other code can check if we are currently locked to a part. 1 2 3 4 5 6 7 8 9 10 11 12 function CameraController : LockTo ( part ) local cam = workspace . CurrentCamera self . Locked = true cam . CameraType = Enum . CameraType . Scriptable cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end function CameraController : Unlock () local cam = workspace . CurrentCamera self . Locked = false cam . CameraType = Enum . CameraType . Custom end","title":"Adding Basic Behavior"},{"location":"controllers/#more-behavior","text":"Right now, when we lock onto a part, we simply set the camera's CFrame once. But what if the part moves? We need to constantly set the camera's CFrame to properly lock onto the part. We can bind to RenderStep to do this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 CameraController . RenderName = \"CustomCamRender\" CameraController . Priority = Enum . RenderPriority . Camera . Value function CameraController : LockTo ( part ) if ( self . Locked ) then return end -- Stop if already locked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = true cam . CameraType = Enum . CameraType . Scriptable -- Bind to RenderStep: runService : BindToRenderStep ( self . RenderName , self . Priority , function () cam . CFrame = part . CFrame * CFrame . new ( 0 , 0 , self . Distance ) end ) end function CameraController : Unlock () if ( not self . Locked ) then return end -- Stop if already unlocked local cam = workspace . CurrentCamera local runService = game : GetService ( \"RunService\" ) self . Locked = false cam . CameraType = Enum . CameraType . Custom -- Unbind: runService : UnbindFromRenderStep ( self . RenderName ) end","title":"More Behavior"},{"location":"controllers/#events","text":"What if we want to create an event that gets fired when the camera is locked and unlocked? We can easily do this! Just create a new signal object as a property of the controller, and fire it in our LockTo and Unlock methods. Let's created a LockedChanged signal. It will pass true when locked and false when unlocked. 1 2 3 4 5 6 7 8 9 10 11 12 13 local Signal = require ( Knit . Util . Signal ) CameraController . LockedChanged = Signal . new () function CameraController : LockTo ( part ) -- Other code... self . LockedChanged : Fire ( true ) end function CameraController : Unlock () -- Other code... self . LockedChanged : Fire ( false ) end Other code could then listen in for that event: 1 2 3 4 5 6 -- Somewhere else on the client local CameraController = Knit . Controllers . CameraController CameraController . LockedChanged : Connect ( function ( isLocked ) print ( isLocked and \"Camera is now locked\" or \"Camera was unlocked\" ) end )","title":"Events"},{"location":"controllers/#server-communication","text":"Knit allows client code to access certain server-side service methods and events that have been explicitly exposed. See the Services: Client Communication section for more info. An example of accessing a service on the server might look like such: 1 2 3 4 5 6 function CameraController : KnitStart () local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () SomeService . SomeEvent : Connect ( function (...) end ) SomeService . AnotherEvent : Fire ( \"Some data\" ) end","title":"Server Communication"},{"location":"controllers/#knitinit-and-knitstart","text":"The KnitInit and KnitStart methods are optional lifecycle methods that can be added to any controller. For more info, check out the service version of this section (which has the same behavior) and the execution model . These methods can be added just like any other method: 1 2 3 4 5 6 7 function CameraController : KnitStart () print ( \"CameraController KnitStart called\" ) end function CameraController : KnitInit () print ( \"CameraController KnitInit called\" ) end","title":"KnitInit and KnitStart"},{"location":"examples/","text":"Start All Services \u00b6 A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script] Services [Folder] MyService [Module] AnotherService [Module] HelloService [Module] We can write our KnitRuntime script as such: 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services: for _ , v in ipairs ( script . Parent . Services : GetDescendants ()) do if ( v : IsA ( \"ModuleScript\" )) then require ( v ) end end Knit . Start (): Catch ( warn ) Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService : 1 2 3 4 5 6 7 8 9 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services within 'Services': Knit . AddServices ( script . Parent . Services ) -- Load all services (the Deep version scans all descendants of the passed instance): Knit . AddServicesDeep ( script . Parent . OtherServices ) Knit . Start (): Catch ( warn ) Tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function. Expose a Collection of Modules \u00b6 Like Knit.Util , we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules , we can expose this within our main runtime script: 1 2 3 4 5 6 7 8 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Expose our MyModules folder: Knit . MyModules = game : GetService ( \"ReplicatedStorage\" ). MyModules -- Load services/controllers Knit . Start () We can then use these modules elsewhere. For instance: 1 local SomeModule = require ( Knit . MyModules . SomeModule )","title":"Examples"},{"location":"examples/#start-all-services","text":"A useful pattern is to keep all service modules within a folder. The script that starts Knit can then require all of these at once. Let's say we have a directory structure like such: Server KnitRuntime [Script] Services [Folder] MyService [Module] AnotherService [Module] HelloService [Module] We can write our KnitRuntime script as such: 1 2 3 4 5 6 7 8 9 10 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services: for _ , v in ipairs ( script . Parent . Services : GetDescendants ()) do if ( v : IsA ( \"ModuleScript\" )) then require ( v ) end end Knit . Start (): Catch ( warn ) Alternatively, we can use Knit.AddServices or Knit.AddServicesDeep to load all of the services without writing a loop. It scans and loads all ModuleScripts found and passes them to Knit.CreateService : 1 2 3 4 5 6 7 8 9 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load all services within 'Services': Knit . AddServices ( script . Parent . Services ) -- Load all services (the Deep version scans all descendants of the passed instance): Knit . AddServicesDeep ( script . Parent . OtherServices ) Knit . Start (): Catch ( warn ) Tip This same design practice can also be done on the client with controllers. Either loop through and collect controllers or use the Knit.AddControllers or Knit.AddControllersDeep function.","title":"Start All Services"},{"location":"examples/#expose-a-collection-of-modules","text":"Like Knit.Util , we can expose a collection of modules to our codebase. This is very simple. All we need to do is add Knit.WHATEVER and point it to a folder of ModuleScripts. For instance, if we had a folder of modules at ReplicatedStorage.MyModules , we can expose this within our main runtime script: 1 2 3 4 5 6 7 8 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Expose our MyModules folder: Knit . MyModules = game : GetService ( \"ReplicatedStorage\" ). MyModules -- Load services/controllers Knit . Start () We can then use these modules elsewhere. For instance: 1 local SomeModule = require ( Knit . MyModules . SomeModule )","title":"Expose a Collection of Modules"},{"location":"executionmodel/","text":"Order of Operations \u00b6 The execution model of Knit defines the flow of operations and lifecycle of the framework. Require the Knit module Create services or controllers Call Knit.Start() , which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finish All KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: 1 2 3 4 5 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load services or controllers here Knit . Start (): Catch ( warn ) Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). Warning Services and controllers cannot be created after Knit.Start() has been called. Catching KnitInit Errors \u00b6 Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: 1 2 3 4 5 local success , err = Knit . Start (): Await () if ( not success ) then -- Handle error error ( tostring ( err )) end 1 2 3 4 Knit . Start (): Catch ( function ( err ) -- Handle error warn ( tostring ( err )) end ) Best Practices \u00b6 Only one Script on the server should manage loading services and starting Knit Only one LocalScript on the client should manage loading controllers and starting Knit Split up services and controllers into their own modules Services should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the client Code within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possible Events and methods should never be added to a service's Client table after Knit.Start() has been called As shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup.","title":"Execution Model"},{"location":"executionmodel/#order-of-operations","text":"The execution model of Knit defines the flow of operations and lifecycle of the framework. Require the Knit module Create services or controllers Call Knit.Start() , which immediately returns a Promise All KnitInit methods are invoked at the same time, and waits for all to finish All KnitStart methods are invoked at the same time After all KnitStart methods are called, the promise returned by Knit.Start() resolves On the server, you should have one Script in ServerScriptService. On the client, you should have one LocalScript in PlayerStarterScripts. Each of these scripts should have a similar layout: 1 2 3 4 5 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Load services or controllers here Knit . Start (): Catch ( warn ) Once services or controllers are created, they persist forever (until the server shuts down or the player leaves). Warning Services and controllers cannot be created after Knit.Start() has been called.","title":"Order of Operations"},{"location":"executionmodel/#catching-knitinit-errors","text":"Due to the way Promises work, errors that occur within KnitInit methods of services or controllers will be caught as a rejected promise. These can be handled by either grabbing the status after using Await or using the Catch() method: 1 2 3 4 5 local success , err = Knit . Start (): Await () if ( not success ) then -- Handle error error ( tostring ( err )) end 1 2 3 4 Knit . Start (): Catch ( function ( err ) -- Handle error warn ( tostring ( err )) end )","title":"Catching KnitInit Errors"},{"location":"executionmodel/#best-practices","text":"Only one Script on the server should manage loading services and starting Knit Only one LocalScript on the client should manage loading controllers and starting Knit Split up services and controllers into their own modules Services should be kept in either ServerStorage or ServerScriptService to avoid being exposed to the client Code within KnitInit and within the root scope of the ModuleScript should try to finish ASAP, and should avoid yielding if possible Events and methods should never be added to a service's Client table after Knit.Start() has been called As shown above in the Catching knitInit Errors section, handling a failure case of Start is the cleanest way to catch errors on startup.","title":"Best Practices"},{"location":"gettingstarted/","text":"Install \u00b6 Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library. Place Knit directly within ReplicatedStorage. Rojo workflow: Download Knit from the latest release on GitHub. Extract the Knit directory from the zipped file. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage. Basic Usage \u00b6 The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 3 4 5 6 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'Await()' to the end to yield until the whole sequence is completed: -- Knit.Start():Catch(warn):Await() That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples. A Simple Service \u00b6 A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money += amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): Catch ( warn ) Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ): Await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): Then ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"Getting Started"},{"location":"gettingstarted/#install","text":"Installing Knit is very simple. Just drop the module into ReplicatedStorage. Knit can also be used within a Rojo project. Roblox Studio workflow: Get Knit from the Roblox library. Place Knit directly within ReplicatedStorage. Rojo workflow: Download Knit from the latest release on GitHub. Extract the Knit directory from the zipped file. Place Knit within your project. Use Rojo to point Knit to ReplicatedStorage.","title":"Install"},{"location":"gettingstarted/#basic-usage","text":"The core usage of Knit is the same from the server and the client. The general pattern is to create a single script on the server and a single script on the client. These scripts will load Knit, create services/controllers, and then start Knit. The most basic usage would look as such: 1 2 3 4 5 6 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ) -- Knit.Start() returns a Promise, so we are catching any errors and feeding it to the built-in 'warn' function -- You could also chain 'Await()' to the end to yield until the whole sequence is completed: -- Knit.Start():Catch(warn):Await() That would be the necessary code on both the server and the client. However, nothing interesting is going to happen. Let's dive into some more examples.","title":"Basic Usage"},{"location":"gettingstarted/#a-simple-service","text":"A service is simply a structure that serves some specific purpose. For instance, a game might have a MoneyService, which manages in-game currency for players. Let's look at a simple example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) -- Create the service: local MoneyService = Knit . CreateService { Name = \"MoneyService\" ; } -- Add some methods to the service: function MoneyService : GetMoney ( player ) -- Do some sort of data fetch local money = someDataStore : GetAsync ( \"money\" ) return money end function MoneyService : GiveMoney ( player , amount ) -- Do some sort of data fetch local money = self : GetMoney ( player ) money += amount someDataStore : SetAsync ( \"money\" , money ) end Knit . Start (): Catch ( warn ) Note It's better practice to put services and controllers within their own ModuleScript and then require them from your main script. For the sake of simplicity, they are all in one script for these examples. Now we have a little MoneyService that can get and give money to a player. However, only the server can use this at the moment. What if we want clients to fetch how much money they have? To do this, we have to create some client-side code to consume our service. We could create a controller, but it's not necessary for this example. First, we need to expose a method to the client. We can do this by writing methods on the service's Client table: 1 2 3 4 5 6 7 8 -- Money service on the server ... function MoneyService . Client : GetMoney ( player ) -- We already wrote this method, so we can just call the other one. -- 'self.Server' will reference back to the root MoneyService. return self . Server : GetMoney ( player ) end ... We can write client-side code to fetch money from the service: 1 2 3 4 5 6 7 8 9 10 11 -- Client-side code local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Knit . Start (): Catch ( warn ): Await () local moneyService = Knit . GetService ( \"MoneyService\" ) local money = moneyService : GetMoney () -- Alternatively, using promises: moneyService : GetMoneyPromise (): Then ( function ( money ) print ( money ) end ) Under the hood, Knit is creating a RemoteFunction bound to the service's GetMoney method. Knit keeps RemoteFunctions and RemoteEvents out of the way so that developers can focus on writing code and not building communication infrastructure. Check out the Services documentation for more info on services.","title":"A Simple Service"},{"location":"knitapi/","text":"Knit \u00b6 Knit.Services: [Service] \u00b6 [Server-side only] A table that contains all created services . 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Controllers: Controller[] \u00b6 [Client-side only] A table that contains all created controllers . 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events). Knit.Util: Folder \u00b6 A folder containing utility modules used by Knit, but also accessible for developers to use. They can be required like any other module: 1 local Signal = require ( Knit . Util . Signal ) Knit.Start() -> Promise \u00b6 Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 11 12 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): Then ( function () print ( \"Knit is running\" ) end ): Catch ( function ( err ) warn ( err ) end ) Alternative ways to start Knit: 1 2 3 4 5 -- Use 'Await' to wait for Knit to start and capture any errors: local success , err = Knit . Start (): Await () if ( not success ) then warn ( err ) end 1 2 -- Feed the 'warn' built-in function directly to the Catch of the returned promise: Knit . Start (): Catch ( warn ) 1 2 3 -- Same as above, but also yield until Knit has started. -- Just note that the 'Catch' will eat up the error, so Await will return successfully even if an error occurs. Knit . Start (): Catch ( warn ): Await () It is important that errors are handled when starting Catch, as any errors within the Init lifecycle will go undetected otherwise. Knit.OnStart() -> Promise \u00b6 Wait for Knit to start. This is useful if there are other scripts that need to access Knit services or controllers. If Knit is already started, it resolves the promise immediately. 1 2 -- Wait for Knit to be started: Knit . OnStart (): Await () Knit.CreateService(service: ServiceDefinition) -> Service \u00b6 [Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} } Knit.AddServices(folder: Instance) \u00b6 [Server-side only] Automatically creates new services from ModuleScripts found directly within folder . 1 Knit . AddServices ( serverStorage . MyServices ) Knit.AddServicesDeep(folder: Instance) \u00b6 [Server-side only] Works the same as Knit.AddServices , but scans all descendants of folder . This is useful if services are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a service. If your services might have non-service modules nested in the descendant hierarchy, use a series of Knit.AddServices instead. 1 Knit . AddServicesDeep ( serverStorage . MyServices ) Knit.CreateController(controller: ControllerDefinition) -> Controller \u00b6 [Client-side only] Creates a new controller . Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" } Knit.AddControllers(folder: Instance) \u00b6 [Client-side only] Automatically creates new controllers from ModuleScripts found directly within folder . 1 Knit . AddControllers ( replicatedStorage . MyControllers ) Knit.AddControllersDeep(folder: Instance) \u00b6 [Client-side only] Works the same as Knit.AddControllers , but scans all descendants of folder . This is useful if controllers are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a controller. If your controllers might have non-controller modules nested in the descendant hierarchy, use a series of Knit.AddControllers instead. 1 Knit . AddControllersDeep ( replicatedStorage . MyControllers ) Knit.GetService(serviceName: string) -> ServiceMirror \u00b6 Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): Then ( function () ... end ) Knit.GetController(controllerName: string) -> Controller \u00b6 [Client-side only] Returns a controller with the given controller name. This is just an alias for Knit.Controllers[controllerName] and only exists for developers who want to have the same pattern used with Knit.GetService . Service \u00b6 A service is a singleton object that serves a specific purpose on the server. Service.Name: string \u00b6 The name of the service. Service.Client: ServiceClient \u00b6 A ServiceClient table that contains client-exposed methods and events. Service:KnitInit() -> void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Service:KnitStart() -> void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Service.CUSTOM_FIELD: any \u00b6 Service:CUSTOM_METHOD(...) -> any \u00b6 Service.CUSTOM_EVENT:Fire(...) -> void \u00b6 ServiceClient \u00b6 Refers to the the Client table within a service . ServiceClient.Server: Service \u00b6 A reference back to the top-level service . ServiceClient:CUSTOM_METHOD(player: Player, ...) -> any \u00b6 ServiceClient.CUSTOM_EVENT:Fire(player: Player, ...) -> void \u00b6 ServiceClient.CUSTOM_EVENT:FireAll(...) -> void \u00b6 ServiceClient.CUSTOM_EVENT:FireExcept(player: Player, ...) -> void \u00b6 Controller \u00b6 A controller is a singleton object that serves a specific purpose on the client. Controller.Name: string \u00b6 The name of the controller. Controller:KnitInit() -> void \u00b6 An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info). Controller:KnitStart() -> void \u00b6 An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info). Controller.CUSTOM_FIELD: any \u00b6 Controller:CUSTOM_METHOD(...) -> any \u00b6 Controller.CUSTOM_EVENT:Fire(...) -> void \u00b6 ServiceMirror \u00b6 A table that mirrors the methods and events that were exposed on the server via the Client table. ServiceMirror:CUSTOM_METHOD(...) -> any \u00b6 ServiceMirror:CUSTOM_METHODPromise(...) -> Promise \u00b6 ServiceMirror.CUSTOM_EVENT:Fire(...) -> void \u00b6 ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -> void \u00b6","title":"Knit API"},{"location":"knitapi/#knit","text":"","title":"Knit"},{"location":"knitapi/#knitservices-service","text":"[Server-side only] A table that contains all created services . 1 2 3 4 local allServices = Knit . Services for name , service in pairs ( allServices ) do print ( name ) end Note Within other services, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other services at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Services: [Service]"},{"location":"knitapi/#knitcontrollers-controller","text":"[Client-side only] A table that contains all created controllers . 1 2 3 4 local allControllers = Knit . Controllers for name , controller in pairs ( allControllers ) do print ( name ) end Note Within other controllers, this table should only be accessed during or after the KnitInit stage. While it is safe to reference other controllers at the KnitInit stage, it is not safe to use them. Wait until the KnitStart stage to start using them (e.g. calling methods and events).","title":"Knit.Controllers: Controller[]"},{"location":"knitapi/#knitutil-folder","text":"A folder containing utility modules used by Knit, but also accessible for developers to use. They can be required like any other module: 1 local Signal = require ( Knit . Util . Signal )","title":"Knit.Util: Folder"},{"location":"knitapi/#knitstart-promise","text":"Start Knit. This returns a promise which resolves once all services or controllers are fully initialized and started. The usage of this is the same on the server and the client. 1 2 3 4 5 6 7 8 9 10 11 12 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) ---- -- Create services or controllers here ---- -- Start Knit: Knit . Start (): Then ( function () print ( \"Knit is running\" ) end ): Catch ( function ( err ) warn ( err ) end ) Alternative ways to start Knit: 1 2 3 4 5 -- Use 'Await' to wait for Knit to start and capture any errors: local success , err = Knit . Start (): Await () if ( not success ) then warn ( err ) end 1 2 -- Feed the 'warn' built-in function directly to the Catch of the returned promise: Knit . Start (): Catch ( warn ) 1 2 3 -- Same as above, but also yield until Knit has started. -- Just note that the 'Catch' will eat up the error, so Await will return successfully even if an error occurs. Knit . Start (): Catch ( warn ): Await () It is important that errors are handled when starting Catch, as any errors within the Init lifecycle will go undetected otherwise.","title":"Knit.Start() -&gt; Promise"},{"location":"knitapi/#knitonstart-promise","text":"Wait for Knit to start. This is useful if there are other scripts that need to access Knit services or controllers. If Knit is already started, it resolves the promise immediately. 1 2 -- Wait for Knit to be started: Knit . OnStart (): Await ()","title":"Knit.OnStart() -&gt; Promise"},{"location":"knitapi/#knitcreateserviceservice-servicedefinition-service","text":"[Server-side only] Creates a new service . Returns the service. Please see the Services documentation for more info. The provided service table must contain a unique Name property. It can optionally contain a Client table as well. If the Client table isn't provided, Knit will automatically create one for the service. 1 local MyService = Knit . CreateService { Name = \"MyService\" , Client = {} }","title":"Knit.CreateService(service: ServiceDefinition) -&gt; Service"},{"location":"knitapi/#knitaddservicesfolder-instance","text":"[Server-side only] Automatically creates new services from ModuleScripts found directly within folder . 1 Knit . AddServices ( serverStorage . MyServices )","title":"Knit.AddServices(folder: Instance)"},{"location":"knitapi/#knitaddservicesdeepfolder-instance","text":"[Server-side only] Works the same as Knit.AddServices , but scans all descendants of folder . This is useful if services are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a service. If your services might have non-service modules nested in the descendant hierarchy, use a series of Knit.AddServices instead. 1 Knit . AddServicesDeep ( serverStorage . MyServices )","title":"Knit.AddServicesDeep(folder: Instance)"},{"location":"knitapi/#knitcreatecontrollercontroller-controllerdefinition-controller","text":"[Client-side only] Creates a new controller . Returns the controller. Please see the Controllers documentation for more info. The provided controller table must contain a unique Name property. 1 local MyController = Knit . CreateController { Name = \"MyController\" }","title":"Knit.CreateController(controller: ControllerDefinition) -&gt; Controller"},{"location":"knitapi/#knitaddcontrollersfolder-instance","text":"[Client-side only] Automatically creates new controllers from ModuleScripts found directly within folder . 1 Knit . AddControllers ( replicatedStorage . MyControllers )","title":"Knit.AddControllers(folder: Instance)"},{"location":"knitapi/#knitaddcontrollersdeepfolder-instance","text":"[Client-side only] Works the same as Knit.AddControllers , but scans all descendants of folder . This is useful if controllers are organized into sub-folders. However, this should be used sparingly, since it will try to load any ModuleScript descendant as a controller. If your controllers might have non-controller modules nested in the descendant hierarchy, use a series of Knit.AddControllers instead. 1 Knit . AddControllersDeep ( replicatedStorage . MyControllers )","title":"Knit.AddControllersDeep(folder: Instance)"},{"location":"knitapi/#knitgetserviceservicename-string-servicemirror","text":"Returns a ServiceMirror table object representing the service. Service methods and events that have been exposed to the client can be used from this returned object. 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomething () Every method will also have a \"Promisefied\" version. Just append \"Promise\" to the name of the event: 1 2 local SomeService = Knit . GetService ( \"SomeService\" ) SomeService : DoSomethingPromise (): Then ( function () ... end )","title":"Knit.GetService(serviceName: string) -&gt; ServiceMirror"},{"location":"knitapi/#knitgetcontrollercontrollername-string-controller","text":"[Client-side only] Returns a controller with the given controller name. This is just an alias for Knit.Controllers[controllerName] and only exists for developers who want to have the same pattern used with Knit.GetService .","title":"Knit.GetController(controllerName: string) -&gt; Controller"},{"location":"knitapi/#service","text":"A service is a singleton object that serves a specific purpose on the server.","title":"Service"},{"location":"knitapi/#servicename-string","text":"The name of the service.","title":"Service.Name: string"},{"location":"knitapi/#serviceclient-serviceclient","text":"A ServiceClient table that contains client-exposed methods and events.","title":"Service.Client: ServiceClient"},{"location":"knitapi/#serviceknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Service:KnitInit() -&gt; void"},{"location":"knitapi/#serviceknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Service:KnitStart() -&gt; void"},{"location":"knitapi/#servicecustom_field-any","text":"","title":"Service.CUSTOM_FIELD: any"},{"location":"knitapi/#servicecustom_method-any","text":"","title":"Service:CUSTOM_METHOD(...) -&gt; any"},{"location":"knitapi/#servicecustom_eventfire-void","text":"","title":"Service.CUSTOM_EVENT:Fire(...) -&gt; void"},{"location":"knitapi/#serviceclient","text":"Refers to the the Client table within a service .","title":"ServiceClient"},{"location":"knitapi/#serviceclientserver-service","text":"A reference back to the top-level service .","title":"ServiceClient.Server: Service"},{"location":"knitapi/#serviceclientcustom_methodplayer-player-any","text":"","title":"ServiceClient:CUSTOM_METHOD(player: Player, ...) -&gt; any"},{"location":"knitapi/#serviceclientcustom_eventfireplayer-player-void","text":"","title":"ServiceClient.CUSTOM_EVENT:Fire(player: Player, ...) -&gt; void"},{"location":"knitapi/#serviceclientcustom_eventfireall-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireAll(...) -&gt; void"},{"location":"knitapi/#serviceclientcustom_eventfireexceptplayer-player-void","text":"","title":"ServiceClient.CUSTOM_EVENT:FireExcept(player: Player, ...) -&gt; void"},{"location":"knitapi/#controller","text":"A controller is a singleton object that serves a specific purpose on the client.","title":"Controller"},{"location":"knitapi/#controllername-string","text":"The name of the controller.","title":"Controller.Name: string"},{"location":"knitapi/#controllerknitinit-void","text":"An optional method that is called during the KnitInit lifecycle stage (see Execution Model for more info).","title":"Controller:KnitInit() -&gt; void"},{"location":"knitapi/#controllerknitstart-void","text":"An optional method that is called during the KnitStart lifecycle stage (see Execution Model for more info).","title":"Controller:KnitStart() -&gt; void"},{"location":"knitapi/#controllercustom_field-any","text":"","title":"Controller.CUSTOM_FIELD: any"},{"location":"knitapi/#controllercustom_method-any","text":"","title":"Controller:CUSTOM_METHOD(...) -&gt; any"},{"location":"knitapi/#controllercustom_eventfire-void","text":"","title":"Controller.CUSTOM_EVENT:Fire(...) -&gt; void"},{"location":"knitapi/#servicemirror","text":"A table that mirrors the methods and events that were exposed on the server via the Client table.","title":"ServiceMirror"},{"location":"knitapi/#servicemirrorcustom_method-any","text":"","title":"ServiceMirror:CUSTOM_METHOD(...) -&gt; any"},{"location":"knitapi/#servicemirrorcustom_methodpromise-promise","text":"","title":"ServiceMirror:CUSTOM_METHODPromise(...) -&gt; Promise"},{"location":"knitapi/#servicemirrorcustom_eventfire-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Fire(...) -&gt; void"},{"location":"knitapi/#servicemirrorcustom_eventconnectfunction-end-void","text":"","title":"ServiceMirror.CUSTOM_EVENT:Connect(function(...) end) -&gt; void"},{"location":"services/","text":"Services Defined \u00b6 Services are singleton objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. For full API documentation, visit the Knit API page. Creating Services \u00b6 In its simplest form, a service can be created like so: 1 2 3 local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } return PointsService Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = \"PointsService\" ). The last line ( return PointsService ) assumes this code is written in a ModuleScript, which is best practice for containing services. Adding methods \u00b6 Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. 1 2 3 4 5 6 7 function PointsService : AddPoints ( player , amount ) -- TODO: add points end function PointsService : GetPoints ( player ) return 0 end Adding properties \u00b6 Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: 1 PointsService . PointsPerPlayer = {} Using methods and properties \u00b6 Now we can change our AddPoints() and GetPoints() methods to use this field. 1 2 3 4 5 6 7 8 9 10 11 12 PointsService . PointsPerPlayer = {} function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) -- Current amount of points points += amount -- Add points self . PointsPerPlayer [ player ] = points -- Store points end function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 -- Return 0 if no points found for player end Using events \u00b6 What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Load the Signal module and create PointsChanged signal: local Signal = require ( Knit . Util . Signal ) PointsService . PointsChanged = Signal . new () -- Modify AddPoints: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points -- Fire event signal, as long as we actually changed the points: if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) end end Another service could then listen for the changes on that event: 1 2 3 4 5 6 function SomeOtherService : KnitStart () local PointsService = Knit . Services . PointsService PointsService . PointsChanged : Connect ( function ( player , points ) print ( \"Points changed for \" .. player . Name .. \":\" , points ) end ) end KnitInit and KnitStart \u00b6 In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model ). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up your service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use. Cleaning Up Unused Memory \u00b6 Alright, back to our PointsService! We have a problem... We have created a memory leak ! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: 1 2 3 4 5 6 function PointsService : KnitInit () game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) -- Clear out the data for hte player when the player leaves: self . PointsPerPlayer [ player ] = nil end ) end While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer. Client Communication \u00b6 Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning. Methods \u00b6 Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: 1 2 3 4 function PointsService . Client : GetPoints ( player ) -- We can just call our other method from here: return self . Server : GetPoints ( player ) end This creates a client-exposed method called GetPoints . Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local points = PointsService : GetPoints () print ( \"Points for myself:\" , points ) Signals (Server-to-Client) \u00b6 We should also create a signal that we can fire events for the clients when their points change. We can use the RemoteSignal module ( Knit.Util.Remote.RemoteSignal ), and just put one within the Client table: 1 PointsService . Client . PointsChanged = RemoteSignal . new () Under the hood, Knit is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: 1 2 3 4 5 6 7 8 9 10 function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) -- Fire the client signal: self . Client . PointsChanged : Fire ( player , points ) end end And from the client, we can listen for an event on the signal: 1 2 3 4 5 6 7 8 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) PointsService . PointsChanged : Connect ( function ( points ) print ( \"Points for myself now:\" , points ) end ) Note Be sure to use RemoteSignal ( not Signal ) for client-exposed events. Signals (Client-to-Server) \u00b6 Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: 1 PointsService . Client . GiveMePoints = RemoteSignal . new () Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: 1 2 3 4 5 6 7 8 9 10 11 12 function PointsService : KnitInit () local rng = Random . new () -- Listen for the client to fire this signal, then give random points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- ...other code for cleaning up player data here end From the client, we can fire the signal like so: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Fire the signal: PointsService . GiveMePoints : Fire () Properties \u00b6 Knit provides a RemoteProperty module to easily expose values to the client. These values are read-only on the client. For our example, let's say that we want to show the most points in the game. First, let's create the RemoteProperty object: 1 2 3 local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) PointsService . Client . MostPoints = RemoteProperty . new ( 0 ) Now, let's change this object whenever we add points: 1 2 3 4 5 6 7 8 function PointsService : AddPoints ( player , amount ) -- Other code from before... -- Set MostPoints value: if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end On the server, the RemoteProperty object has Set and Get methods, and also has a Changed event. On the client, it only has the Get method and Changed event (no Set method on the client; read-only). Let's grab this value on the client: 1 2 3 4 5 6 7 8 9 10 11 12 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Grab value: local mostPoints = PointsService . MostPoints : Get () -- Keep it updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end ) Full Example \u00b6 PointsService \u00b6 At the end of this tutorial, we should have a PointsService that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local RemoteSignal = require ( Knit . Util . Remote . RemoteSignal ) local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } -- Server-exposed signals/fields: PointsService . PointsPerPlayer = {} PointsService . PointsChanged = Signal . new () -- Client exposed signals: PointsService . Client . PointsChanged = RemoteSignal . new () PointsService . Client . GiveMePoints = RemoteSignal . new () -- Client exposed properties: PointsService . Client . MostPoints = RemoteProperty . new ( 0 ) -- Client exposed GetPoints method: function PointsService . Client : GetPoints ( player ) return self . Server : GetPoints ( player ) end -- Add Points: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) self . Client . PointsChanged : Fire ( player , points ) end if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end -- Get Points: function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 end -- Initialize function PointsService : KnitInit () local rng = Random . new () -- Give player random amount of points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- Clean up data when player leaves: game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) self . PointsPerPlayer [ player ] = nil end ) end return PointsService Alternatively, we could have put all non-methods within the CreateService constructor: 1 2 3 4 5 6 7 8 9 10 11 12 local PointsService = Knit . CreateService { Name = \"PointsService\" ; PointsPerPlayer = {}; PointsChanged = Signal . new (); Client = { PointsChanged = RemoteSignal . new (); GiveMePoints = RemoteSignal . new (); MostPoints = RemoteProperty . new ( 0 ); }; } -- The rest of code here Client Consumer \u00b6 Example of client-side LocalScript consuming the PointsService: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local function PointsChanged ( points ) print ( \"My points:\" , points ) end -- Get points and listen for changes: local initialPoints = PointsService : GetPoints () PointsChanged ( initialPoints ) PointsService . PointsChanged : Connect ( PointsChanged ) -- Ask server to give points randomly: PointsService . GiveMePoints : Fire () -- Grab MostPoints value: local mostPoints = PointsService . MostPoints : Get () -- Keep MostPoints value updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end ) -- Advanced example, using promises to get points: PointsService : GetPointsPromise (): Then ( function ( points ) print ( \"Got points:\" , points ) end )","title":"Services"},{"location":"services/#services-defined","text":"Services are singleton objects that serve a specific purpose on the server. For instance, a game might have a PointsService, which manages in-game points for the players. A game might have many services. They will serve as the backbone of a game. For the sake of example, we will slowly develop PointsService to show how a service is constructed. For full API documentation, visit the Knit API page.","title":"Services Defined"},{"location":"services/#creating-services","text":"In its simplest form, a service can be created like so: 1 2 3 local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } return PointsService Client table optional The Client table is optional for the constructor. However, it will be added by Knit if left out. For the sake of code clarity, it is recommended to keep it in the constructor as shown above. The Name field is required. This name is how code outside of your service will find it. This name must be unique from all other services. It is best practice to name your variable the same as the service name (e.g. local PointsService matches Name = \"PointsService\" ). The last line ( return PointsService ) assumes this code is written in a ModuleScript, which is best practice for containing services.","title":"Creating Services"},{"location":"services/#adding-methods","text":"Services are just simple tables at the end of the day. As such, it is very easy to add methods to services. 1 2 3 4 5 6 7 function PointsService : AddPoints ( player , amount ) -- TODO: add points end function PointsService : GetPoints ( player ) return 0 end","title":"Adding methods"},{"location":"services/#adding-properties","text":"Again, services are just tables. So we can simply add in properties as we want. In our above method, we are returning 0 for GetPoints() because we have nowhere to store/retrieve points. Likewise, our AddPoints() method can't do anything. Let's change that. Let's create a property that holds a table of points per player: 1 PointsService . PointsPerPlayer = {}","title":"Adding properties"},{"location":"services/#using-methods-and-properties","text":"Now we can change our AddPoints() and GetPoints() methods to use this field. 1 2 3 4 5 6 7 8 9 10 11 12 PointsService . PointsPerPlayer = {} function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) -- Current amount of points points += amount -- Add points self . PointsPerPlayer [ player ] = points -- Store points end function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 -- Return 0 if no points found for player end","title":"Using methods and properties"},{"location":"services/#using-events","text":"What if we want to fire an event when the amount of points changes? This is easy. We can assign an event named PointsChanged as a property of our service, and have our AddPoints() method fire the event: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- Load the Signal module and create PointsChanged signal: local Signal = require ( Knit . Util . Signal ) PointsService . PointsChanged = Signal . new () -- Modify AddPoints: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points -- Fire event signal, as long as we actually changed the points: if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) end end Another service could then listen for the changes on that event: 1 2 3 4 5 6 function SomeOtherService : KnitStart () local PointsService = Knit . Services . PointsService PointsService . PointsChanged : Connect ( function ( player , points ) print ( \"Points changed for \" .. player . Name .. \":\" , points ) end ) end","title":"Using events"},{"location":"services/#knitinit-and-knitstart","text":"In that last code snippet, there's an odd KnitStart() method. This is part of the Knit lifecycle (read more under execution model ). These methods are optional, but very useful for orchestrating communication between other services. When a service is first created, it is not guaranteed that other services are also created and ready to be used. The KnitInit and KnitStart methods come to save the day! After all services are created and the Knit.Start() method is fired, the KnitInit methods of all services will be fired. From the KnitInit method, we can guarantee that all other services have been created. However, we still cannot guarantee that those services are ready to be consumed. Therefore, we can reference them within the Init step, but we should never use them (e.g. use the methods or events attached to those other services). After all KnitInit methods have finished, all KnitStart methods are then fired. At this point, we can guarantee that all KnitInits are done, and thus can freely access other services. In order to maintain this pattern, be sure to set up your service in the Init method (or earlier; just in the ModuleScript itself). By the time KnitStart methods are being fired, your services should be available for use.","title":"KnitInit and KnitStart"},{"location":"services/#cleaning-up-unused-memory","text":"Alright, back to our PointsService! We have a problem... We have created a memory leak ! When we add points for a player, we add the player to the table. What happens when the player leaves? Nothing! And that's a problem. That player's data is forever held onto within that PointsPerPlayer table. To fix this, we need to clear out that data when the player leaves. We can use the KnitInit method to hook up to the Players.PlayerRemoving event and remove the data: 1 2 3 4 5 6 function PointsService : KnitInit () game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) -- Clear out the data for hte player when the player leaves: self . PointsPerPlayer [ player ] = nil end ) end While memory management is not unique to Knit, it is still an important aspect to consider when making your game. Even a garbage-collected language like Lua can have memory leaks introduced by the developer.","title":"Cleaning Up Unused Memory"},{"location":"services/#client-communication","text":"Alright, so we can store and add points on the server for a player. But who cares? Players have no visibility to these points at the moment. We need to open a line of communication between our service and the clients (AKA players). This functionality is so fundamental to Knit, that it's where the name came from: The need to knit together communication. This is where we are going to use that Client table defined at the beginning.","title":"Client Communication"},{"location":"services/#methods","text":"Let's say that we want to create a method that lets players fetch how many points they have, and when their points change. First, let's make a method to fetch points: 1 2 3 4 function PointsService . Client : GetPoints ( player ) -- We can just call our other method from here: return self . Server : GetPoints ( player ) end This creates a client-exposed method called GetPoints . Within it, we reach back to our top-level service using self.Server and then invoke our other GetPoints method that we wrote before. In this example, we've basically just created a proxy for another method; however, this will not always be the case. There will be many times where a client method will exist alone without an equivalent server-side-only method. Under the hood, Knit will create a RemoteFunction and bind this method to it. On the client, we could then invoke the service as such: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local points = PointsService : GetPoints () print ( \"Points for myself:\" , points )","title":"Methods"},{"location":"services/#signals-server-to-client","text":"We should also create a signal that we can fire events for the clients when their points change. We can use the RemoteSignal module ( Knit.Util.Remote.RemoteSignal ), and just put one within the Client table: 1 PointsService . Client . PointsChanged = RemoteSignal . new () Under the hood, Knit is creating a RemoteEvent object linked to this event. This is a two-way signal (like a transceiver), so we can both send and receive data on both the server and the client. We can then modify our AddPoints method again to fire this signal too: 1 2 3 4 5 6 7 8 9 10 function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) -- Fire the client signal: self . Client . PointsChanged : Fire ( player , points ) end end And from the client, we can listen for an event on the signal: 1 2 3 4 5 6 7 8 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) PointsService . PointsChanged : Connect ( function ( points ) print ( \"Points for myself now:\" , points ) end ) Note Be sure to use RemoteSignal ( not Signal ) for client-exposed events.","title":"Signals (Server-to-Client)"},{"location":"services/#signals-client-to-server","text":"Signal events can also be fired from the client. This is useful when the client needs to give the server information, but doesn't care about any response from the server. For instance, maybe the client wants to tell the PointsService that it wants some points. This is an odd use-case, but let's just roll with it. We will create another client-exposed signal called GiveMePoints which will randomly give the player points. Again, this is nonsense in the context of an actual game, but useful for example. Let's create the signal on the PointsService: 1 PointsService . Client . GiveMePoints = RemoteSignal . new () Now, let's listen for the client to fire this signal. We can hook this up in our KnitInit method: 1 2 3 4 5 6 7 8 9 10 11 12 function PointsService : KnitInit () local rng = Random . new () -- Listen for the client to fire this signal, then give random points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- ...other code for cleaning up player data here end From the client, we can fire the signal like so: 1 2 3 4 5 6 7 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Fire the signal: PointsService . GiveMePoints : Fire ()","title":"Signals (Client-to-Server)"},{"location":"services/#properties","text":"Knit provides a RemoteProperty module to easily expose values to the client. These values are read-only on the client. For our example, let's say that we want to show the most points in the game. First, let's create the RemoteProperty object: 1 2 3 local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) PointsService . Client . MostPoints = RemoteProperty . new ( 0 ) Now, let's change this object whenever we add points: 1 2 3 4 5 6 7 8 function PointsService : AddPoints ( player , amount ) -- Other code from before... -- Set MostPoints value: if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end On the server, the RemoteProperty object has Set and Get methods, and also has a Changed event. On the client, it only has the Get method and Changed event (no Set method on the client; read-only). Let's grab this value on the client: 1 2 3 4 5 6 7 8 9 10 11 12 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) -- Grab value: local mostPoints = PointsService . MostPoints : Get () -- Keep it updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end )","title":"Properties"},{"location":"services/#full-example","text":"","title":"Full Example"},{"location":"services/#pointsservice","text":"At the end of this tutorial, we should have a PointsService that looks something like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local RemoteSignal = require ( Knit . Util . Remote . RemoteSignal ) local RemoteProperty = require ( Knit . Util . Remote . RemoteProperty ) local PointsService = Knit . CreateService { Name = \"PointsService\" , Client = {} } -- Server-exposed signals/fields: PointsService . PointsPerPlayer = {} PointsService . PointsChanged = Signal . new () -- Client exposed signals: PointsService . Client . PointsChanged = RemoteSignal . new () PointsService . Client . GiveMePoints = RemoteSignal . new () -- Client exposed properties: PointsService . Client . MostPoints = RemoteProperty . new ( 0 ) -- Client exposed GetPoints method: function PointsService . Client : GetPoints ( player ) return self . Server : GetPoints ( player ) end -- Add Points: function PointsService : AddPoints ( player , amount ) local points = self : GetPoints ( player ) points += amount self . PointsPerPlayer [ player ] = points if ( amount ~= 0 ) then self . PointsChanged : Fire ( player , points ) self . Client . PointsChanged : Fire ( player , points ) end if ( points > self . Client . MostPoints : Get ()) then self . Client . MostPoints : Set ( points ) end end -- Get Points: function PointsService : GetPoints ( player ) local points = self . PointsPerPlayer [ player ] return points or 0 end -- Initialize function PointsService : KnitInit () local rng = Random . new () -- Give player random amount of points: self . Client . GiveMePoints : Connect ( function ( player ) local points = rng : NextInteger ( 0 , 10 ) self : AddPoints ( player , points ) print ( \"Gave \" .. player . Name .. \" \" .. points .. \" points\" ) end ) -- Clean up data when player leaves: game : GetService ( \"Players\" ). PlayerRemoving : Connect ( function ( player ) self . PointsPerPlayer [ player ] = nil end ) end return PointsService Alternatively, we could have put all non-methods within the CreateService constructor: 1 2 3 4 5 6 7 8 9 10 11 12 local PointsService = Knit . CreateService { Name = \"PointsService\" ; PointsPerPlayer = {}; PointsChanged = Signal . new (); Client = { PointsChanged = RemoteSignal . new (); GiveMePoints = RemoteSignal . new (); MostPoints = RemoteProperty . new ( 0 ); }; } -- The rest of code here","title":"PointsService"},{"location":"services/#client-consumer","text":"Example of client-side LocalScript consuming the PointsService: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 -- From a LocalScript local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local PointsService = Knit . GetService ( \"PointsService\" ) local function PointsChanged ( points ) print ( \"My points:\" , points ) end -- Get points and listen for changes: local initialPoints = PointsService : GetPoints () PointsChanged ( initialPoints ) PointsService . PointsChanged : Connect ( PointsChanged ) -- Ask server to give points randomly: PointsService . GiveMePoints : Fire () -- Grab MostPoints value: local mostPoints = PointsService . MostPoints : Get () -- Keep MostPoints value updated: PointsService . MostPoints . Changed : Connect ( function ( newMostPoints ) mostPoints = newMostPoints end ) -- Advanced example, using promises to get points: PointsService : GetPointsPromise (): Then ( function ( points ) print ( \"Got points:\" , points ) end )","title":"Client Consumer"},{"location":"styleguide/","text":"Knit Style Guide \u00b6 For those who want to contribute to Knit, here are some guidelines in regards to code style. Readability \u00b6 Readability is king. Code within Knit should not be impressive; it should be readable. Having readable code is important for debugging and future maintainability. This also means that code shouldn't be prematurely optimized with fancy Lua tricks unless absolutely necessary. In almost all cases, such optimizations only make the code unreadable and add no real value. Single Purpose Files \u00b6 Every source file within Knit should have a single purpose. This might be a single class, table, function, etc. For instance, a source file should not contain a bunch of public classes. Split these into separate files. File Structure \u00b6 File names should match the name of the module. All source files should follow a similar format to this template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Header (author, date, etc.) -- Documentation -- Module requires (e.g. Module = require(somewhere.Module)) -- Service refs (e.g. RunService = game:GetService(\"RunService\")) -- Constants (e.g. MY_CONSTANT = 10) -- Variables (although, global vars are looked down upon) -- Module definition (e.g. MyModule = {}) -- Module code -- Return module In other Roblox programming ecosystems, it is usually standard for service refs to come before module requires. The reason for the switch here is that imports are always first in just about every other ecosystem, and thus Knit tries to follow the more global standard. Example of MyModule.lua : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 -- MyModule -- John Doe -- January 10, 2021 --[[ MyModule.DoSomething(value: number) MyModule.DoAnotherThing() MyModule.DidSomething(value: number) --]] local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local HttpService = game : GetService ( \"HttpService\" ) local MESSAGE = \"Hello\" local MyModule = {} MyModule . DidSomething = Signal . new () function MyModule . DoSomething ( value ) -- Do something MyModule . DidSomething : Fire ( value ) end function MyModule . DoAnotherThing () -- Do something else end return MyModule Spacing \u00b6 Between each section above, there should be a blank line of separation. Two blank lines should exist around methods and functions. Variables \u00b6 Variables should be descriptive and should be written in camelCase . 1 local amountLeft = 10 Constants \u00b6 Variables that should act as constants (non-changing variables) should be written in UPPER_SNAKE_CASE . 1 2 local MAX_INTERVAL = 20 local DEFAULT_TEXT = \"Hello\" Services and Requires \u00b6 Services retrieved using game:GetService or modules retrieved using require should be written in PascalCase . 1 2 local Signal = require ( Knit . Util . Signal ) local RunService = game : GetService ( \"RunService\" ) Functions \u00b6 Function names should be written in PascalCase and declared with local if possible. Functions should be short and easy to understand. When possible, prefer functional programming techniques, so that side effects are avoided. In other words, functions should only manipulate the variables within the function or passed as arguments, and the function should not change any variables outside of the function's scope. 1 2 3 4 local function HelloWorld ( message ) local newMessage = \"The message was: \" .. message return newMessage end Classes \u00b6 Classes should be defined with the following boilerplate code: 1 2 3 4 5 6 7 8 9 10 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end It is important that classes have a Destroy method so that they can be passed to Janitors for cleanup. Method & Field Names \u00b6 Public method and field names should be written in PascalCase . Private method and field names should be written in _underscoreCamelCase . Fields should be declared within the new constructor. For readability, it is preferred to add the fields after the setmetatable line. Please note that it is technically faster to declare fields within the table declaration, but readability is key. Only the class itself should ever access private methods or fields. If other code is accessing these methods or fields, it is probably due to bad design. Switch those methods/fields to be public or redesign how those items are being accessed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function MyClass . new () local self = setmetatable ({}, MyClass ) self . MyPublicField = \"Hello world\" self . _myPrivateField = \"Goodbye earth\" return self end function MyClass : SomeMethod () local combined = ( self . MyPublicField .. \" \" .. self . _myPrivateField ) return combined end function MyClass : _somePrivateMethod () return self . MyPublicField : rep ( 10 ) end Public or Private \u00b6 When deciding if a method or field should be public or private, ask these questions: Does the method/field need to be accessed by code outside of this class? If yes, the method/field should be public. If no, keep it private. Simply underscoring the name of a method/field gives no actual security to those methods/fields. It is only a convention. It helps authors know if they should be accessing the methods/fields. An assumption can be made that accessing or manipulating private methods/fields is bad and can result in unexpected behavior, and is thus better avoided. Method or Function \u00b6 It is important to decide whether a piece of code should exist as a method or as a function. This can be figured out quite simply: Is is required that external code can invoke this function, and does it need any information about the object itself? If the answer is \"no\" to both of these questions, then it should exist as a standalone function. Standalone functions in class modules should be defined above the class definition. Documentation \u00b6 At the top of each source file, simple documentation should be given to show how to use the module. This should show method signatures, fields, and events. If needed, short examples of usage can be shown too. While Lua is a dynamic language, it is helpful to include types for arguments and return values. For instance: Symbol.Is(obj: any): boolean , which shows that obj can be any type, and a boolean is the expected return type. The typical layout is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 --[[ -- CONSTRUCTOR DEFINITIONS -- -- FIELD DEFINITIONS -- -- METHOD DEFINITIONS -- -- EVENT DEFINITIONS -- -- EXAMPLES IF NEEDED -- --]] Example: 1 2 3 4 5 6 7 8 9 --[[ myClass = MyClass.new() myClass.MyPublicField: string myClass:SomeMethod(): string --]] Other Material \u00b6 Outside of styling defined in this guide, follow the Roblox Lua Style Guide .","title":"Style Guide"},{"location":"styleguide/#knit-style-guide","text":"For those who want to contribute to Knit, here are some guidelines in regards to code style.","title":"Knit Style Guide"},{"location":"styleguide/#readability","text":"Readability is king. Code within Knit should not be impressive; it should be readable. Having readable code is important for debugging and future maintainability. This also means that code shouldn't be prematurely optimized with fancy Lua tricks unless absolutely necessary. In almost all cases, such optimizations only make the code unreadable and add no real value.","title":"Readability"},{"location":"styleguide/#single-purpose-files","text":"Every source file within Knit should have a single purpose. This might be a single class, table, function, etc. For instance, a source file should not contain a bunch of public classes. Split these into separate files.","title":"Single Purpose Files"},{"location":"styleguide/#file-structure","text":"File names should match the name of the module. All source files should follow a similar format to this template: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 -- Header (author, date, etc.) -- Documentation -- Module requires (e.g. Module = require(somewhere.Module)) -- Service refs (e.g. RunService = game:GetService(\"RunService\")) -- Constants (e.g. MY_CONSTANT = 10) -- Variables (although, global vars are looked down upon) -- Module definition (e.g. MyModule = {}) -- Module code -- Return module In other Roblox programming ecosystems, it is usually standard for service refs to come before module requires. The reason for the switch here is that imports are always first in just about every other ecosystem, and thus Knit tries to follow the more global standard. Example of MyModule.lua : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 -- MyModule -- John Doe -- January 10, 2021 --[[ MyModule.DoSomething(value: number) MyModule.DoAnotherThing() MyModule.DidSomething(value: number) --]] local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Signal = require ( Knit . Util . Signal ) local HttpService = game : GetService ( \"HttpService\" ) local MESSAGE = \"Hello\" local MyModule = {} MyModule . DidSomething = Signal . new () function MyModule . DoSomething ( value ) -- Do something MyModule . DidSomething : Fire ( value ) end function MyModule . DoAnotherThing () -- Do something else end return MyModule","title":"File Structure"},{"location":"styleguide/#spacing","text":"Between each section above, there should be a blank line of separation. Two blank lines should exist around methods and functions.","title":"Spacing"},{"location":"styleguide/#variables","text":"Variables should be descriptive and should be written in camelCase . 1 local amountLeft = 10","title":"Variables"},{"location":"styleguide/#constants","text":"Variables that should act as constants (non-changing variables) should be written in UPPER_SNAKE_CASE . 1 2 local MAX_INTERVAL = 20 local DEFAULT_TEXT = \"Hello\"","title":"Constants"},{"location":"styleguide/#services-and-requires","text":"Services retrieved using game:GetService or modules retrieved using require should be written in PascalCase . 1 2 local Signal = require ( Knit . Util . Signal ) local RunService = game : GetService ( \"RunService\" )","title":"Services and Requires"},{"location":"styleguide/#functions","text":"Function names should be written in PascalCase and declared with local if possible. Functions should be short and easy to understand. When possible, prefer functional programming techniques, so that side effects are avoided. In other words, functions should only manipulate the variables within the function or passed as arguments, and the function should not change any variables outside of the function's scope. 1 2 3 4 local function HelloWorld ( message ) local newMessage = \"The message was: \" .. message return newMessage end","title":"Functions"},{"location":"styleguide/#classes","text":"Classes should be defined with the following boilerplate code: 1 2 3 4 5 6 7 8 9 10 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end It is important that classes have a Destroy method so that they can be passed to Janitors for cleanup.","title":"Classes"},{"location":"styleguide/#method-field-names","text":"Public method and field names should be written in PascalCase . Private method and field names should be written in _underscoreCamelCase . Fields should be declared within the new constructor. For readability, it is preferred to add the fields after the setmetatable line. Please note that it is technically faster to declare fields within the table declaration, but readability is key. Only the class itself should ever access private methods or fields. If other code is accessing these methods or fields, it is probably due to bad design. Switch those methods/fields to be public or redesign how those items are being accessed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function MyClass . new () local self = setmetatable ({}, MyClass ) self . MyPublicField = \"Hello world\" self . _myPrivateField = \"Goodbye earth\" return self end function MyClass : SomeMethod () local combined = ( self . MyPublicField .. \" \" .. self . _myPrivateField ) return combined end function MyClass : _somePrivateMethod () return self . MyPublicField : rep ( 10 ) end","title":"Method &amp; Field Names"},{"location":"styleguide/#public-or-private","text":"When deciding if a method or field should be public or private, ask these questions: Does the method/field need to be accessed by code outside of this class? If yes, the method/field should be public. If no, keep it private. Simply underscoring the name of a method/field gives no actual security to those methods/fields. It is only a convention. It helps authors know if they should be accessing the methods/fields. An assumption can be made that accessing or manipulating private methods/fields is bad and can result in unexpected behavior, and is thus better avoided.","title":"Public or Private"},{"location":"styleguide/#method-or-function","text":"It is important to decide whether a piece of code should exist as a method or as a function. This can be figured out quite simply: Is is required that external code can invoke this function, and does it need any information about the object itself? If the answer is \"no\" to both of these questions, then it should exist as a standalone function. Standalone functions in class modules should be defined above the class definition.","title":"Method or Function"},{"location":"styleguide/#documentation","text":"At the top of each source file, simple documentation should be given to show how to use the module. This should show method signatures, fields, and events. If needed, short examples of usage can be shown too. While Lua is a dynamic language, it is helpful to include types for arguments and return values. For instance: Symbol.Is(obj: any): boolean , which shows that obj can be any type, and a boolean is the expected return type. The typical layout is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 13 --[[ -- CONSTRUCTOR DEFINITIONS -- -- FIELD DEFINITIONS -- -- METHOD DEFINITIONS -- -- EVENT DEFINITIONS -- -- EXAMPLES IF NEEDED -- --]] Example: 1 2 3 4 5 6 7 8 9 --[[ myClass = MyClass.new() myClass.MyPublicField: string myClass:SomeMethod(): string --]]","title":"Documentation"},{"location":"styleguide/#other-material","text":"Outside of styling defined in this guide, follow the Roblox Lua Style Guide .","title":"Other Material"},{"location":"vscodesnippets/","text":"Being able to quickly create services, controllers, or other Knit-related items is very useful when using Knit as a framework. To keep Knit lightweight, there are no required extensions or plugins. Instead, below are some VS Code snippets that can be used to speed up development. Using Snippets \u00b6 Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -> Preferences -> User Snippets Type in and select lua.json Within the {} braces, include any or all of the snippets below Save the file Within your actual source files, start typing a prefix (e.g. \"knit\") and select the autocompleted snippet to paste it in Depending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service) Knit Snippets \u00b6 Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage. Knit \u00b6 Include a require statement for Knit. Snippet 1 2 3 4 5 \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" } Code Result 1 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) Service \u00b6 Reference a Roblox service. Snippet 1 2 3 4 5 \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" } Code Result 1 local HttpService = game : GetService ( \"HttpService\" ) Knit Service \u00b6 Reference Knit, create a service, and return the service. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyService = Knit . CreateService { Name = \"MyService\" ; Client = {}; } function MyService : KnitStart () end function MyService : KnitInit () end return MyService Knit Controller \u00b6 Reference Knit, create a controller, and return the controller. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyController = Knit . CreateController { Name = \"MyController\" ; } function MyController : KnitStart () end function MyController : KnitInit () end return MyController Knit Component \u00b6 Create a Knit component. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Janitor = require(Knit.Util.Janitor)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._janitor = Janitor.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._janitor:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Janitor = require ( Knit . Util . Janitor ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Init () end function MyComponent : Deinit () end function MyComponent : Destroy () self . _janitor : Destroy () end return MyComponent Knit Require \u00b6 Require a module within Knit. Snippet 1 2 3 4 5 \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } Code Result 1 local Janitor = require ( Knit . Util . Janitor ) Lua Class \u00b6 A standard Lua class. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end return MyClass All \u00b6 All the above snippets together. All Snippets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 { \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" }, \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" }, \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" }, \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Janitor = require(Knit.Util.Janitor)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._janitor = Janitor.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._janitor:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" }, \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" }, \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" }, \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } }","title":"VS Code Snippets"},{"location":"vscodesnippets/#using-snippets","text":"Snippets are a Visual Studio Code feature. Check out the Snippets documentation for more info. Adding Snippets for Lua is very easy. Within Visual Studio, navigate from the toolbar: File -> Preferences -> User Snippets Type in and select lua.json Within the {} braces, include any or all of the snippets below Save the file Within your actual source files, start typing a prefix (e.g. \"knit\") and select the autocompleted snippet to paste it in Depending on the snippet, parts of the pasted code will be selected and can be typed over (e.g. setting the name of a service)","title":"Using Snippets"},{"location":"vscodesnippets/#knit-snippets","text":"Below are useful VS Code snippets for Knit. The snippets assume that the Knit module has been placed within ReplicatedStorage.","title":"Knit Snippets"},{"location":"vscodesnippets/#knit","text":"Include a require statement for Knit. Snippet 1 2 3 4 5 \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" } Code Result 1 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit )","title":"Knit"},{"location":"vscodesnippets/#service","text":"Reference a Roblox service. Snippet 1 2 3 4 5 \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" } Code Result 1 local HttpService = game : GetService ( \"HttpService\" )","title":"Service"},{"location":"vscodesnippets/#knit-service","text":"Reference Knit, create a service, and return the service. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyService = Knit . CreateService { Name = \"MyService\" ; Client = {}; } function MyService : KnitStart () end function MyService : KnitInit () end return MyService","title":"Knit Service"},{"location":"vscodesnippets/#knit-controller","text":"Reference Knit, create a controller, and return the controller. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local MyController = Knit . CreateController { Name = \"MyController\" ; } function MyController : KnitStart () end function MyController : KnitInit () end return MyController","title":"Knit Controller"},{"location":"vscodesnippets/#knit-component","text":"Create a Knit component. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Janitor = require(Knit.Util.Janitor)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._janitor = Janitor.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._janitor:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Janitor = require ( Knit . Util . Janitor ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Init () end function MyComponent : Deinit () end function MyComponent : Destroy () self . _janitor : Destroy () end return MyComponent","title":"Knit Component"},{"location":"vscodesnippets/#knit-require","text":"Require a module within Knit. Snippet 1 2 3 4 5 \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } Code Result 1 local Janitor = require ( Knit . Util . Janitor )","title":"Knit Require"},{"location":"vscodesnippets/#lua-class","text":"A standard Lua class. Snippet 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" } Code Result 1 2 3 4 5 6 7 8 9 10 11 12 13 local MyClass = {} MyClass . __index = MyClass function MyClass . new () local self = setmetatable ({}, MyClass ) return self end function MyClass : Destroy () end return MyClass","title":"Lua Class"},{"location":"vscodesnippets/#all","text":"All the above snippets together. All Snippets 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 { \"Service\" : { \"prefix\" : [ \"service\" ], \"body\" : [ \"local ${0:Name}Service = game:GetService(\\\"${0:Name}Service\\\")\" ], \"description\" : \"Roblox Service\" }, \"Class\" : { \"prefix\" : [ \"class\" ], \"body\" : [ \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new()\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\treturn self\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Lua Class\" }, \"Knit\" : { \"prefix\" : [ \"knit\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" ], \"description\" : \"Require the Knit module\" }, \"Knit Component\" : { \"prefix\" : [ \"knitcomponent\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"local Janitor = require(Knit.Util.Janitor)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = {}\" , \"${0:$TM_FILENAME_BASE}.__index = ${0:$TM_FILENAME_BASE}\" , \"\" , \"${0:$TM_FILENAME_BASE}.Tag = \\\"${0:$TM_FILENAME_BASE}\\\"\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}.new(instance)\" , \"\\t\" , \"\\tlocal self = setmetatable({}, ${0:$TM_FILENAME_BASE})\" , \"\\t\" , \"\\tself._janitor = Janitor.new()\" , \"\\t\" , \"\\treturn self\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Init()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Deinit()\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:Destroy()\" , \"\\tself._janitor:Destroy()\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Component template\" }, \"Knit Service\" : { \"prefix\" : [ \"knitservice\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateService {\" , \"\\tName = \\\"${0:$TM_FILENAME_BASE}\\\";\" , \"\\tClient = {};\" , \"}\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Service template\" }, \"Knit Controller\" : { \"prefix\" : [ \"knitcontroller\" ], \"body\" : [ \"local Knit = require(game:GetService(\\\"ReplicatedStorage\\\").Knit)\" , \"\" , \"local ${0:$TM_FILENAME_BASE} = Knit.CreateController { Name = \\\"${0:$TM_FILENAME_BASE}\\\" }\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitStart()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"function ${0:$TM_FILENAME_BASE}:KnitInit()\" , \"\\t\" , \"end\" , \"\" , \"\" , \"return ${0:$TM_FILENAME_BASE}\" ], \"description\" : \"Knit Controller template\" }, \"Knit Require\" : { \"prefix\" : [ \"knitrequire\" ], \"body\" : [ \"local ${1:Name} = require(Knit.${2:Util}.${1:Name})\" ], \"description\" : \"Knit Require template\" } }","title":"All"},{"location":"whyknit/","text":"Why Knit? \u00b6 In Response to AGF \u00b6 Knit is a response to the underlying issues of AeroGameFramework (AGF). Some problems of AGF: Pigeon-holes developers into a specific code structure Hard to update and manage Hard to migrate existing code Not easy to share or distribute services/controllers Doesn't support code outside of structure Knit fixes these problems by having a modular structure. Knit can just be dropped in and used. It can be added to an existing codebase and slowly migrated. Anyone can write a plain module service/controller and distribute it to others. Knit still holds onto the core mission of AGF: Create an environment where modules of code can freely talk to each other in a structured manner, including crossing the server/client boundary. Structure (If you want) \u00b6 Knit gives developers the ability to create services and controllers, which gives a game structure. However, not all the code has to live in either of these two systems. Code can live alone and still consume services and controllers. Developers are free to organize codebases in any way. Framework / Library Hybrid \u00b6 While advertised as a game framework, Knit straddles the line between a framework and a library. While Knit provides optional structure using services and controllers, developers can choose if and how these structures are utilized. Developers are also responsible for creating the runtime scripts for Knit, which allows easy extensibility of the framework.","title":"Why Knit"},{"location":"whyknit/#why-knit","text":"","title":"Why Knit?"},{"location":"whyknit/#in-response-to-agf","text":"Knit is a response to the underlying issues of AeroGameFramework (AGF). Some problems of AGF: Pigeon-holes developers into a specific code structure Hard to update and manage Hard to migrate existing code Not easy to share or distribute services/controllers Doesn't support code outside of structure Knit fixes these problems by having a modular structure. Knit can just be dropped in and used. It can be added to an existing codebase and slowly migrated. Anyone can write a plain module service/controller and distribute it to others. Knit still holds onto the core mission of AGF: Create an environment where modules of code can freely talk to each other in a structured manner, including crossing the server/client boundary.","title":"In Response to AGF"},{"location":"whyknit/#structure-if-you-want","text":"Knit gives developers the ability to create services and controllers, which gives a game structure. However, not all the code has to live in either of these two systems. Code can live alone and still consume services and controllers. Developers are free to organize codebases in any way.","title":"Structure (If you want)"},{"location":"whyknit/#framework-library-hybrid","text":"While advertised as a game framework, Knit straddles the line between a framework and a library. While Knit provides optional structure using services and controllers, developers can choose if and how these structures are utilized. Developers are also responsible for creating the runtime scripts for Knit, which allows easy extensibility of the framework.","title":"Framework / Library Hybrid"},{"location":"util/component/","text":"The Component class allows developers to bind custom component classes to in-game objects based on tags provided by the CollectionService . The best practice is to keep all components as descendants of a folder and then call Component.Auto(folder) to load all the components automatically. This process is looks for component modules in all descendants of the given folder. Dance Floor Example \u00b6 For instance, a component might be created called DanceFloor , which has the purpose of making a part flash random colors. Here's what our DanceFloor component module might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 local DanceFloor = {} DanceFloor . __index = DanceFloor -- The CollectionService tag to bind: DanceFloor . Tag = \"DanceFloor\" -- [Optional] The RenderPriority to be used when using the RenderUpdate lifecycle method: DanceFloor . RenderPriority = Enum . RenderPriority . Camera . Value -- [Optional] The other components that must exist on a given instance before this one can exist: DanceFloor . RequiredComponents = {} -- How often the color changes: local UPDATE_INTERVAL = 0.5 function DanceFloor . new () local self = setmetatable ({}, DanceFloor ) self . _nextUpdate = time () + UPDATE_INTERVAL return self end function DanceFloor : HeartbeatUpdate ( dt ) if ( time () > self . _nextUpdate ) then -- Set the assigned instance to a random color: self . Instance . Color = Color3 . new ( math.random (), math.random (), math.random () ) self . _nextUpdate = self . _nextUpdate + UPDATE_INTERVAL end end function DanceFloor : Destroy () end return DanceFloor Within your runtime script, load in all components using Component.Auto : 1 2 3 4 5 6 7 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Component = require ( Knit . Util . Component ) Knit . Start (): Await () -- Load all components in some folder: Component . Auto ( script . Parent . Components ) Simply assign parts within the game with the DanceFloor tag, and the DanceFloor component will automatically be instantiated for those objects. For editing tags within Studio, check out the Tag Editor plugin. Components can live in either the server or the client. It is not recommended to use the exact same component module for both the server and the client. Instead, it is best to create separate components for the server and client. For instance, there could be a DanceFloor component on the server and a ClientDanceFloor component on the client. Because this component is flashing colors quickly, it is probably best to run this component on the client, rather than the server. Component Instance \u00b6 A component instance is the instantiated object from your component class. In other words, this is the object being created when your component's .new() constructor is called. 1 2 3 4 5 function MyComponent . new ( robloxInstance ) -- This is the component instance: local self = setmetatable ({}, MyComponent ) return self end Roblox Instance \u00b6 Component instances are bound to a Roblox instance. This is injected into the component instance after the constructor is completed (it is identical to the robloxInstance argument passed to the constructor). This can be accessed as the .Instance field on the component instance. For example, here is the Roblox instance being referenced within the initializer: 1 2 3 function MyComponent : Init () print ( \"I am bound to: \" .. self . Instance : GetFullName ()) end Lifecycle Methods \u00b6 Components have special \"lifecycle methods\" which will automatically fire during the lifecycle of the component. The available methods are Init , Deinit , Destroy , HeartbeatUpdate , SteppedUpdated , and RenderUpdate . The only required of these is Destroy ; the rest are optional. Init & Deinit \u00b6 Init fires a tick/frame after the constructor has fired. Deinit fires right before the component's Destroy method is called. Both Init and Deinit are optional. Destroy \u00b6 Destroy is fired internally when the component becomes unbound from the instance. A component is destroyed when one of the following conditions occurs: The bound instance is destroyed The bound instance no longer has the component tag anymore The bound instance no longer has the required components attached anymore (see section on Required Components ) It is recommended to use janitors in components and to only have the janitor cleanup within the Destroy method. Any other cleanup logic should just be added to the janitor: 1 2 3 4 5 6 7 8 9 function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Destroy () self . _janitor : Destroy () end HeartbeatUpdate & SteppedUpdate \u00b6 These optional methods are fired when RunService.Heartbeat and RunService.Stepped are fired. The delta time argument from the event is passed as an argument to the methods. 1 2 3 4 5 6 function MyComponent : HeartbeatUpdate ( dt ) print ( \"Update!\" , dt ) end function MyComponent : SteppedUpdate ( dt ) print ( \"Update!\" , dt ) end RenderUpdate \u00b6 The RenderUpdate optional method uses RunService:BindToRenderStep internally, using your component's RenderPriority field as the priority for binding. Just like HeartbeatUpdate and SteppedUpdate , the delta time is passed along to the method. 1 2 3 4 5 MyComponent . RenderPriority = Enum . RenderPriority . Camera . Value function MyComponent : RenderUpdate ( dt ) print ( \"Render update\" , dt ) end Required Components \u00b6 Being able to extend instances by binding multiple components is very useful. However, if these components need to communicate, it is required to use the RequiredComponents optional table to indicate which components are necessary for instantiation. For example, let's say we have a Vehicle component and a Truck component. The Truck component must have the Vehicle component in order to operate. The Truck component also needs to invoke methods on the Vehicle component. We can make this guarantee using the RequiredComponents table on the Truck : 1 2 3 4 5 6 local Truck = {} Truck . __index = Truck Truck . Tag = \"Truck\" -- Set the 'Vehicle' as a required component: Truck . RequiredComponents = { \"Vehicle\" } With that done, the Truck component will only bind to an instance with the \"Truck\" tag if the instance already has a Vehicle component bound to it. If the Vehicle component becomes unbound for any reason, the Truck component will also be unbound and destroyed. Because of this guarantee, we can reference the Vehicle component within the Truck constructor safely: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Component = require ( Knit . Util . Component ) ... Truck . RequiredComponents = { \"Vehicle\" } function Truck . new ( instance ) local self = setmetatable ({}, Truck ) -- Get the Vehicle component on this instance: self . Vehicle = Component . FromTag ( \"Vehicle\" ): GetFromInstance ( instance ) return self end Component API \u00b6 Static Methods \u00b6 1 2 3 Component.Auto(folder: Instance): void Component.FromTag(tag: string): ComponentInstance | nil Component.ObserveFromTag(tag: string, observer: (component: Component, janitor: Janitor) -> void): Janitor Auto \u00b6 Automatically create components from the component module descendants of the given instance. 1 Component . Auto ( someFolder ) FromTag \u00b6 Get a component from the tag name, which assumes the component class has already been loaded. This will return nil if not found. 1 local MyComponent = Component . FromTag ( \"MyComponent\" ) ObserveFromTag \u00b6 Observe a component with the given tag name. Unless component classes will be destroyed and reconstructed often, this method is most likely not going to be needed in your code. 1 2 3 Component . ObserveFromTag ( \"MyComponent\" , function ( MyComponent , janitor ) -- Use MyComponent end ) Constructor \u00b6 1 Component.new(tag: string, class: table [, renderPriority: RenderPriority, requiredComponents: table]) 1 2 3 4 5 6 7 local MyComponentClass = require ( somewhere . MyComponent ) local MyComponent = Component . new ( MyComponentClass . Tag , MyComponentClass , MyComponentClass . RenderPriority , MyComponentClass . RequiredComponents ) Note While the constructor can be called directly, it is recommended to use Component.Auto instead. Methods \u00b6 1 2 3 4 5 6 component:GetAll(): ComponentInstance[] component:GetFromInstance(instance: Instance): ComponentInstance | nil component:Filter(filterFunc: (comp: ComponentInstance) -> boolean): ComponentInstance[] component:WaitFor(instance: Instance [, timeout: number = 60]): Promise<ComponentInstance> component:Observe(instance: Instance, observer: (component: ComponentInstance, janitor: Janitor) -> void): Janitor component:Destroy() GetAll \u00b6 Gets all component instances for the given component class. 1 2 3 4 local MyComponent = Component . FromTag ( \"MyComponent\" ) for _ , component in ipairs ( MyComponent : GetAll ()) do print ( component . Instance : GetFullName ()) end GetFromInstance \u00b6 Gets a component instance from the given Roblox instance. If no component is found, nil is returned. 1 2 local MyComponent = Component . FromTag ( \"MyComponent\" ) local component = MyComponent : GetFromInstance ( workspace . SomePart ) Filter \u00b6 Returns a filtered list from all components for a given component class. This is equivalent to calling GetAll and running it through TableUtil.Filter . 1 2 3 4 local MyComponent = Component . FromTag ( \"MyComponent\" ) local componentsStartWithC = MyComponent : Filter ( function ( component ) return component . Instance . Name : sub ( 1 , 1 ): lower () == \"c\" end ) WaitFor \u00b6 Waits for a component to be bound to a given instance. Returns a promise that is resolved when the component is bound, or rejected when either the timeout is reached or the instance is removed. 1 2 3 4 local MyComponent = Component . FromTag ( \"MyComponent\" ) MyComponent : WaitFor ( workspace . SomePart ): Then ( function ( component ) print ( \"Got component\" ) end ): Catch ( warn ) Observe \u00b6 Observes when a component is bound to a given instance. Returns a janitor that can be destroyed. 1 2 3 4 5 6 7 local MyComponent = Component . FromTag ( \"MyComponent\" ) local observeJanitor = MyComponent : Observe ( workspace . SomePart , function ( component , janitor ) -- Do something janitor : Add ( function () -- Cleanup end ) end ) Warning This does not clean itself up if the instance is destroyed. This should be handled explicitly in your code. Destroy \u00b6 If the component is not needed anymore, Destroy can be called to clean it up. Typically, components are never destroyed. 1 2 local MyComponent = Component . FromTag ( \"MyComponent\" ) MyComponent : Destroy () Events \u00b6 1 2 component.Added(obj: ComponentInstance) component.Removed(obj: ComponentInstance) Boilerplate Examples \u00b6 Here is the most basic component with the recommended Janitor pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Janitor = require ( Knit . Util . Janitor ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Destroy () self . _janitor : Destroy () end return MyComponent Here is a more robust example with lifecycles and required components: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Janitor = require ( Knit . Util . Janitor ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" MyComponent . RenderPriority = Enum . RenderPriority . Camera . Value MyComponent . RequiredComponents = { \"AnotherComponent\" , \"YetAnotherComponent\" } function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Init () print ( \"Initialized. Bound to: \" , self . Instance : GetFullName ()) end function MyComponent : Deinit () print ( \"About to clean up\" ) end function MyComponent : HeartbeatUpdate ( dt ) print ( \"Heartbeat\" , dt ) end function MyComponent : SteppedUpdate ( dt ) print ( \"Stepped\" , dt ) end function MyComponent : RenderUpdate ( dt ) print ( \"Render\" , dt ) end function MyComponent : Destroy () self . _janitor : Destroy () end return MyComponent","title":"Component"},{"location":"util/component/#dance-floor-example","text":"For instance, a component might be created called DanceFloor , which has the purpose of making a part flash random colors. Here's what our DanceFloor component module might look like: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 local DanceFloor = {} DanceFloor . __index = DanceFloor -- The CollectionService tag to bind: DanceFloor . Tag = \"DanceFloor\" -- [Optional] The RenderPriority to be used when using the RenderUpdate lifecycle method: DanceFloor . RenderPriority = Enum . RenderPriority . Camera . Value -- [Optional] The other components that must exist on a given instance before this one can exist: DanceFloor . RequiredComponents = {} -- How often the color changes: local UPDATE_INTERVAL = 0.5 function DanceFloor . new () local self = setmetatable ({}, DanceFloor ) self . _nextUpdate = time () + UPDATE_INTERVAL return self end function DanceFloor : HeartbeatUpdate ( dt ) if ( time () > self . _nextUpdate ) then -- Set the assigned instance to a random color: self . Instance . Color = Color3 . new ( math.random (), math.random (), math.random () ) self . _nextUpdate = self . _nextUpdate + UPDATE_INTERVAL end end function DanceFloor : Destroy () end return DanceFloor Within your runtime script, load in all components using Component.Auto : 1 2 3 4 5 6 7 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Component = require ( Knit . Util . Component ) Knit . Start (): Await () -- Load all components in some folder: Component . Auto ( script . Parent . Components ) Simply assign parts within the game with the DanceFloor tag, and the DanceFloor component will automatically be instantiated for those objects. For editing tags within Studio, check out the Tag Editor plugin. Components can live in either the server or the client. It is not recommended to use the exact same component module for both the server and the client. Instead, it is best to create separate components for the server and client. For instance, there could be a DanceFloor component on the server and a ClientDanceFloor component on the client. Because this component is flashing colors quickly, it is probably best to run this component on the client, rather than the server.","title":"Dance Floor Example"},{"location":"util/component/#component-instance","text":"A component instance is the instantiated object from your component class. In other words, this is the object being created when your component's .new() constructor is called. 1 2 3 4 5 function MyComponent . new ( robloxInstance ) -- This is the component instance: local self = setmetatable ({}, MyComponent ) return self end","title":"Component Instance"},{"location":"util/component/#roblox-instance","text":"Component instances are bound to a Roblox instance. This is injected into the component instance after the constructor is completed (it is identical to the robloxInstance argument passed to the constructor). This can be accessed as the .Instance field on the component instance. For example, here is the Roblox instance being referenced within the initializer: 1 2 3 function MyComponent : Init () print ( \"I am bound to: \" .. self . Instance : GetFullName ()) end","title":"Roblox Instance"},{"location":"util/component/#lifecycle-methods","text":"Components have special \"lifecycle methods\" which will automatically fire during the lifecycle of the component. The available methods are Init , Deinit , Destroy , HeartbeatUpdate , SteppedUpdated , and RenderUpdate . The only required of these is Destroy ; the rest are optional.","title":"Lifecycle Methods"},{"location":"util/component/#init-deinit","text":"Init fires a tick/frame after the constructor has fired. Deinit fires right before the component's Destroy method is called. Both Init and Deinit are optional.","title":"Init &amp; Deinit"},{"location":"util/component/#destroy","text":"Destroy is fired internally when the component becomes unbound from the instance. A component is destroyed when one of the following conditions occurs: The bound instance is destroyed The bound instance no longer has the component tag anymore The bound instance no longer has the required components attached anymore (see section on Required Components ) It is recommended to use janitors in components and to only have the janitor cleanup within the Destroy method. Any other cleanup logic should just be added to the janitor: 1 2 3 4 5 6 7 8 9 function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Destroy () self . _janitor : Destroy () end","title":"Destroy"},{"location":"util/component/#heartbeatupdate-steppedupdate","text":"These optional methods are fired when RunService.Heartbeat and RunService.Stepped are fired. The delta time argument from the event is passed as an argument to the methods. 1 2 3 4 5 6 function MyComponent : HeartbeatUpdate ( dt ) print ( \"Update!\" , dt ) end function MyComponent : SteppedUpdate ( dt ) print ( \"Update!\" , dt ) end","title":"HeartbeatUpdate &amp; SteppedUpdate"},{"location":"util/component/#renderupdate","text":"The RenderUpdate optional method uses RunService:BindToRenderStep internally, using your component's RenderPriority field as the priority for binding. Just like HeartbeatUpdate and SteppedUpdate , the delta time is passed along to the method. 1 2 3 4 5 MyComponent . RenderPriority = Enum . RenderPriority . Camera . Value function MyComponent : RenderUpdate ( dt ) print ( \"Render update\" , dt ) end","title":"RenderUpdate"},{"location":"util/component/#required-components","text":"Being able to extend instances by binding multiple components is very useful. However, if these components need to communicate, it is required to use the RequiredComponents optional table to indicate which components are necessary for instantiation. For example, let's say we have a Vehicle component and a Truck component. The Truck component must have the Vehicle component in order to operate. The Truck component also needs to invoke methods on the Vehicle component. We can make this guarantee using the RequiredComponents table on the Truck : 1 2 3 4 5 6 local Truck = {} Truck . __index = Truck Truck . Tag = \"Truck\" -- Set the 'Vehicle' as a required component: Truck . RequiredComponents = { \"Vehicle\" } With that done, the Truck component will only bind to an instance with the \"Truck\" tag if the instance already has a Vehicle component bound to it. If the Vehicle component becomes unbound for any reason, the Truck component will also be unbound and destroyed. Because of this guarantee, we can reference the Vehicle component within the Truck constructor safely: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Component = require ( Knit . Util . Component ) ... Truck . RequiredComponents = { \"Vehicle\" } function Truck . new ( instance ) local self = setmetatable ({}, Truck ) -- Get the Vehicle component on this instance: self . Vehicle = Component . FromTag ( \"Vehicle\" ): GetFromInstance ( instance ) return self end","title":"Required Components"},{"location":"util/component/#component-api","text":"","title":"Component API"},{"location":"util/component/#static-methods","text":"1 2 3 Component.Auto(folder: Instance): void Component.FromTag(tag: string): ComponentInstance | nil Component.ObserveFromTag(tag: string, observer: (component: Component, janitor: Janitor) -> void): Janitor","title":"Static Methods"},{"location":"util/component/#auto","text":"Automatically create components from the component module descendants of the given instance. 1 Component . Auto ( someFolder )","title":"Auto"},{"location":"util/component/#fromtag","text":"Get a component from the tag name, which assumes the component class has already been loaded. This will return nil if not found. 1 local MyComponent = Component . FromTag ( \"MyComponent\" )","title":"FromTag"},{"location":"util/component/#observefromtag","text":"Observe a component with the given tag name. Unless component classes will be destroyed and reconstructed often, this method is most likely not going to be needed in your code. 1 2 3 Component . ObserveFromTag ( \"MyComponent\" , function ( MyComponent , janitor ) -- Use MyComponent end )","title":"ObserveFromTag"},{"location":"util/component/#constructor","text":"1 Component.new(tag: string, class: table [, renderPriority: RenderPriority, requiredComponents: table]) 1 2 3 4 5 6 7 local MyComponentClass = require ( somewhere . MyComponent ) local MyComponent = Component . new ( MyComponentClass . Tag , MyComponentClass , MyComponentClass . RenderPriority , MyComponentClass . RequiredComponents ) Note While the constructor can be called directly, it is recommended to use Component.Auto instead.","title":"Constructor"},{"location":"util/component/#methods","text":"1 2 3 4 5 6 component:GetAll(): ComponentInstance[] component:GetFromInstance(instance: Instance): ComponentInstance | nil component:Filter(filterFunc: (comp: ComponentInstance) -> boolean): ComponentInstance[] component:WaitFor(instance: Instance [, timeout: number = 60]): Promise<ComponentInstance> component:Observe(instance: Instance, observer: (component: ComponentInstance, janitor: Janitor) -> void): Janitor component:Destroy()","title":"Methods"},{"location":"util/component/#getall","text":"Gets all component instances for the given component class. 1 2 3 4 local MyComponent = Component . FromTag ( \"MyComponent\" ) for _ , component in ipairs ( MyComponent : GetAll ()) do print ( component . Instance : GetFullName ()) end","title":"GetAll"},{"location":"util/component/#getfrominstance","text":"Gets a component instance from the given Roblox instance. If no component is found, nil is returned. 1 2 local MyComponent = Component . FromTag ( \"MyComponent\" ) local component = MyComponent : GetFromInstance ( workspace . SomePart )","title":"GetFromInstance"},{"location":"util/component/#filter","text":"Returns a filtered list from all components for a given component class. This is equivalent to calling GetAll and running it through TableUtil.Filter . 1 2 3 4 local MyComponent = Component . FromTag ( \"MyComponent\" ) local componentsStartWithC = MyComponent : Filter ( function ( component ) return component . Instance . Name : sub ( 1 , 1 ): lower () == \"c\" end )","title":"Filter"},{"location":"util/component/#waitfor","text":"Waits for a component to be bound to a given instance. Returns a promise that is resolved when the component is bound, or rejected when either the timeout is reached or the instance is removed. 1 2 3 4 local MyComponent = Component . FromTag ( \"MyComponent\" ) MyComponent : WaitFor ( workspace . SomePart ): Then ( function ( component ) print ( \"Got component\" ) end ): Catch ( warn )","title":"WaitFor"},{"location":"util/component/#observe","text":"Observes when a component is bound to a given instance. Returns a janitor that can be destroyed. 1 2 3 4 5 6 7 local MyComponent = Component . FromTag ( \"MyComponent\" ) local observeJanitor = MyComponent : Observe ( workspace . SomePart , function ( component , janitor ) -- Do something janitor : Add ( function () -- Cleanup end ) end ) Warning This does not clean itself up if the instance is destroyed. This should be handled explicitly in your code.","title":"Observe"},{"location":"util/component/#destroy_1","text":"If the component is not needed anymore, Destroy can be called to clean it up. Typically, components are never destroyed. 1 2 local MyComponent = Component . FromTag ( \"MyComponent\" ) MyComponent : Destroy ()","title":"Destroy"},{"location":"util/component/#events","text":"1 2 component.Added(obj: ComponentInstance) component.Removed(obj: ComponentInstance)","title":"Events"},{"location":"util/component/#boilerplate-examples","text":"Here is the most basic component with the recommended Janitor pattern: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Janitor = require ( Knit . Util . Janitor ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Destroy () self . _janitor : Destroy () end return MyComponent Here is a more robust example with lifecycles and required components: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 local Knit = require ( game : GetService ( \"ReplicatedStorage\" ). Knit ) local Janitor = require ( Knit . Util . Janitor ) local MyComponent = {} MyComponent . __index = MyComponent MyComponent . Tag = \"MyComponent\" MyComponent . RenderPriority = Enum . RenderPriority . Camera . Value MyComponent . RequiredComponents = { \"AnotherComponent\" , \"YetAnotherComponent\" } function MyComponent . new ( instance ) local self = setmetatable ({}, MyComponent ) self . _janitor = Janitor . new () return self end function MyComponent : Init () print ( \"Initialized. Bound to: \" , self . Instance : GetFullName ()) end function MyComponent : Deinit () print ( \"About to clean up\" ) end function MyComponent : HeartbeatUpdate ( dt ) print ( \"Heartbeat\" , dt ) end function MyComponent : SteppedUpdate ( dt ) print ( \"Stepped\" , dt ) end function MyComponent : RenderUpdate ( dt ) print ( \"Render\" , dt ) end function MyComponent : Destroy () self . _janitor : Destroy () end return MyComponent","title":"Boilerplate Examples"},{"location":"util/janitor/","text":"The Janitor class manages the cleanup of instances, connections, promises, or anything else. A typical pattern is to use a Janitor within other classes. Instances and connections created by said classes can be added to janitors and then automatically cleaned up when destructed. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local Janitor = require ( Knit . Util . Janitor ) local janitor = Janitor . new () -- Instances added to janitors will be destroyed when the janitor is cleaned up: janitor : Add ( Instance . new ( \"Folder\" )) -- Janitors can also track RBXScriptConnections: janitor : Add ( workspace . Changed : Connect ( function () end )) -- Janitors can also be given functions, which will be fired on cleanup: janitor : Add ( function () print ( \"Cleanup\" ) end ) -- Janitors can be given promises, which will be cancelled if cleaned up: janitor : AddPromise ( Promise . new ( function ( resolve , reject ) ... end )) -- Janitors can be linked to an instance. The janitor will clean up once the instance is destroyed: janitor : LinkToInstance ( workspace . SomeModel ) -- Clean up all items added: janitor : Cleanup () -- Clean up and destroy the janitor: janitor : Destroy () Check out the API Reference for more info.","title":"Janitor"},{"location":"util/option/","text":"An Option is a powerful concept taken from Rust and other languages. The purpose is to represent an optional value. An option can either be Some or None . Using Options helps reduce nil bugs (which can cause silent bugs that can be hard to track down). Options automatically serialize/deserialize across the server/client boundary when passed through services or controllers. For full documentation, check out the LuaOption repository. Using Options is very simple: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 local Option = require ( Knit . Util . Option ) -- Returns an Option: local function DoSomething () local rng = Random . new () local value = rng : NextNumber () if ( value > 0.5 ) then return Option . Some ( value ) else return Option . None end end -- Get option value: local value = DoSomething () -- Match if the value is 'some' or 'none': value : Match { Some = function ( value ) print ( \"Got value:\" , value ) end , None = function () print ( \"Got no value\" ) end } -- Optionally, use IsSome() and Unwrap(): if ( value : IsSome ()) then print ( \"Got value:\" , value : Unwrap ()) end Because these are automatically serialized/deserialized in services and controllers, they work great in cases where a returned result is uncertain: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 -- SERVICE: local MyService = Knit . CreateService { Name = \"MyService\" } local Option = require ( Knit . Util . Option ) function MyService . Client : GetWeapon ( player , weaponName ) local weapon = TryToGetWeaponSomehow ( player , weaponName ) if ( weapon ) then return Option . Some ( weapon ) else return Option . None end end ---- -- CONTROLLER: local MyController = Knit . CreateController { Name = \"MyController\" } function MyController : KnitStart () local MyService = Knit . GetService ( \"MyService\" ) local weaponOption = MyService : GetWeapon ( \"SomeWeapon\" ) weaponOption : Match { Some = function ( weapon ) --[[ Do something with weapon ]] end , None = function () warn ( \"No weapon found\" ) end } end Note Attempting to unwrap an option with no value will throw an error. This is intentional. The purpose is to avoid unhandled nil cases. Whenever calling Unwrap() , be sure that IsSome() was first checked. Using the Match pattern is the easiest way to handle both Some and None cases.","title":"Option"},{"location":"util/promise/","text":"The Promise module reproduces the behavior of Promises common in web programming, written by evaera . Promises are incredibly useful for managing asynchronous flows. Read the official documentation for usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 local Promise = require ( Knit . Util . Promise ) local function Fetch ( url ) return Promise . new ( function ( resolve , reject ) local success , result = pcall ( function () return game : GetService ( \"HttpService\" ): GetAsync ( url ) end ) if ( success ) then resolve ( result ) else reject ( result ) end end ) end Fetch ( \"https://www.example.com\" ) : Then ( function ( result ) print ( result ) end ) : Catch ( function ( err ) warn ( err ) end )","title":"Promise"},{"location":"util/remoteproperty/","text":"The RemoteProperty module wraps a ValueBase object to expose properties to the client from the server. The server can read and write to this object, but the client can only read. This is useful when it's overkill to write a combination of a method and event to replicate data to the client. When a RemoteProperty is created on the server, a value must be passed to the constructor. The type of the value will determine the ValueBase chosen. For instance, if a string is passed, it will instantiate a StringValue internally. The server can then set/get this value. On the client, a RemoteProperty must be instantiated by giving the ValueBase to the constructor. 1 2 3 4 5 local property = RemoteProperty . new ( 10 ) property : Set ( 30 ) property : Replicate () -- Only for table values local value = property : Get () property . Changed : Connect ( function ( newValue ) end ) Tables When using a table in a RemoteProperty, you must call property:Replicate() server-side after changing a value in the table in order for the changes to replicate to the client. This is necessary because there is no way to watch for changes on a table (unless you clutter it with a bunch of metatables). Calling Replicate will replicate the table to the clients. ClientRemoteProperty \u00b6 The ClientRemoteProperty module wraps a ValueBase object to expose properties from the server to the client. The client can only read the value. This class should be used alongside RemoteProperty on the server. Typically, developers will never need to instantiate ClientRemoteProperties, as they are automatically created for services on the client if the service has a RemoteProperty defined in its Client table. However, the class is exposed to developers in case custom workflows are being used. 1 2 3 4 -- Client-side local property = ClientRemoteProperty . new ( valueBaseObject ) local value = property : Get () property . Changed : Connect ( function ( newValue ) end )","title":"RemoteProperty"},{"location":"util/remoteproperty/#clientremoteproperty","text":"The ClientRemoteProperty module wraps a ValueBase object to expose properties from the server to the client. The client can only read the value. This class should be used alongside RemoteProperty on the server. Typically, developers will never need to instantiate ClientRemoteProperties, as they are automatically created for services on the client if the service has a RemoteProperty defined in its Client table. However, the class is exposed to developers in case custom workflows are being used. 1 2 3 4 -- Client-side local property = ClientRemoteProperty . new ( valueBaseObject ) local value = property : Get () property . Changed : Connect ( function ( newValue ) end )","title":"ClientRemoteProperty"},{"location":"util/remotesignal/","text":"The RemoteSignal module wraps the RemoteEvent object and is typically used within services. The only time a developer should ever have to instantiate a RemoteSignal is within the Client table of a service. For use on the client, see ClientRemoteSignal. 1 2 3 4 5 6 7 8 9 10 11 local remoteSignal = RemoteSignal . new () remoteSignal : Fire ( player , ...) remoteSignal : FireExcept ( player , ...) remoteSignal : FireAll (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler ( player , ...)) connection : IsConnected () connection : Disconnect () ClientRemoteSignal \u00b6 The ClientRemoteSignal module wraps the RemoteEvent object and is typically used within services. Usually, ClientRemoteSignals are created behind-the-scenes and don't need to be instantiated by developers. However, it is available for developers in case custom workflows are being used. 1 2 3 4 5 6 7 8 9 local remoteSignal = ClientRemoteSignal . new ( remoteEventObject ) remoteSignal : Fire (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler (...)) connection : IsConnected () connection : Disconnect ()","title":"RemoteSignal"},{"location":"util/remotesignal/#clientremotesignal","text":"The ClientRemoteSignal module wraps the RemoteEvent object and is typically used within services. Usually, ClientRemoteSignals are created behind-the-scenes and don't need to be instantiated by developers. However, it is available for developers in case custom workflows are being used. 1 2 3 4 5 6 7 8 9 local remoteSignal = ClientRemoteSignal . new ( remoteEventObject ) remoteSignal : Fire (...) remoteSignal : Wait () remoteSignal : Destroy () local connection = remoteSignal : Connect ( functionHandler (...)) connection : IsConnected () connection : Disconnect ()","title":"ClientRemoteSignal"},{"location":"util/signal/","text":"The Signal module gives basic Roblox Signal functionality. Signals are key to event-driven programming in Roblox. 1 local Signal = require ( Knit . Util . Signal ) Constructors \u00b6 new([janitor: Janitor]) \u00b6 Creates a new signal. If a Janitor is passed ot the constructor, the signal will be added to the janitor for future cleanup. 1 2 3 4 5 6 7 8 9 -- Create a signal: local signal = Signal . new () -- Create a signal with a janitor: local signal = Signal . new ( janitor ) -- The above is equivalent to: local signal = Signal . new () janitor : Add ( signal ) Wrap(signal: RBXScriptSignal [, janitor: Janitor]) \u00b6 Wraps an existing RBXScriptSignal. This is useful when simply proxying a built-in signal that should have all connections disconnected at some point. 1 local signal = Signal . Wrap () Static Functions \u00b6 Is(obj: any) \u00b6 Returns true if the given obj is a Signal. 1 2 3 4 local signal = Signal . new () print ( Signal . Is ( signal )) --> true print ( Signal . Is ( \"abc\" )) --> false Methods \u00b6 Fire(...) \u00b6 Fire the signal with any number of arguments. Internally, this uses task.spawn and optimizes to reuse the same coroutine when possible. 1 signal : Fire (...) FireDeferred(...) \u00b6 Fires the signal with any number of arguments. Internally, this uses task.defer . This does not reuse coroutines, but does take advantage of the built-in deferral scheduling. 1 signal : FireDeferred (...) Wait() \u00b6 Yields the current thread until the signal fires & returns all arguments fired. 1 local arg1 , arg2 , arg3 = signal : Wait () Promise([predicate: (...) -> boolean]) \u00b6 Returns a promise that is resolved once the signal is fired. This promise is also cancellable. A predicate function can optionally be passed to signal which event should resolve the promise. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- Resolve promise the first time the signal is fired: signal : Promise (): Then ( function ( arg1 , arg2 , arg3 ) print ( arg1 , arg2 , arg3 ) --> 10, 15, 20 end ) signal : Fire ( 10 , 15 , 20 ) -- Using predicate to signal when promise should resolve: local function IsPositive ( num ) return num >= 0 end signal : Promise ( IsPositive ): Then ( function ( positiveNum ) print ( positiveNum ) --> 15 end ) signal : Fire ( - 20 ) signal : Fire ( - 5 ) signal : Fire ( 15 ) Connect(fn: (...) -> void) \u00b6 Connects a function to the signal and returns a connection object. 1 2 3 4 5 6 7 8 9 local connection = signal : Connect ( function ( arg1 , arg2 , arg3 ) ... end ) -- Connections can be disconnected connection : Disconnect () -- Check if a connection is still connected if connection . Connected then ... end DisconnectAll() \u00b6 1 2 -- Disconnects all connections to the signal signal : DisconnectAll () Destroy() \u00b6 1 2 -- Destroys the signal signal : Destroy ()","title":"Signal"},{"location":"util/signal/#constructors","text":"","title":"Constructors"},{"location":"util/signal/#newjanitor-janitor","text":"Creates a new signal. If a Janitor is passed ot the constructor, the signal will be added to the janitor for future cleanup. 1 2 3 4 5 6 7 8 9 -- Create a signal: local signal = Signal . new () -- Create a signal with a janitor: local signal = Signal . new ( janitor ) -- The above is equivalent to: local signal = Signal . new () janitor : Add ( signal )","title":"new([janitor: Janitor])"},{"location":"util/signal/#wrapsignal-rbxscriptsignal-janitor-janitor","text":"Wraps an existing RBXScriptSignal. This is useful when simply proxying a built-in signal that should have all connections disconnected at some point. 1 local signal = Signal . Wrap ()","title":"Wrap(signal: RBXScriptSignal [, janitor: Janitor])"},{"location":"util/signal/#static-functions","text":"","title":"Static Functions"},{"location":"util/signal/#isobj-any","text":"Returns true if the given obj is a Signal. 1 2 3 4 local signal = Signal . new () print ( Signal . Is ( signal )) --> true print ( Signal . Is ( \"abc\" )) --> false","title":"Is(obj: any)"},{"location":"util/signal/#methods","text":"","title":"Methods"},{"location":"util/signal/#fire","text":"Fire the signal with any number of arguments. Internally, this uses task.spawn and optimizes to reuse the same coroutine when possible. 1 signal : Fire (...)","title":"Fire(...)"},{"location":"util/signal/#firedeferred","text":"Fires the signal with any number of arguments. Internally, this uses task.defer . This does not reuse coroutines, but does take advantage of the built-in deferral scheduling. 1 signal : FireDeferred (...)","title":"FireDeferred(...)"},{"location":"util/signal/#wait","text":"Yields the current thread until the signal fires & returns all arguments fired. 1 local arg1 , arg2 , arg3 = signal : Wait ()","title":"Wait()"},{"location":"util/signal/#promisepredicate-boolean","text":"Returns a promise that is resolved once the signal is fired. This promise is also cancellable. A predicate function can optionally be passed to signal which event should resolve the promise. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -- Resolve promise the first time the signal is fired: signal : Promise (): Then ( function ( arg1 , arg2 , arg3 ) print ( arg1 , arg2 , arg3 ) --> 10, 15, 20 end ) signal : Fire ( 10 , 15 , 20 ) -- Using predicate to signal when promise should resolve: local function IsPositive ( num ) return num >= 0 end signal : Promise ( IsPositive ): Then ( function ( positiveNum ) print ( positiveNum ) --> 15 end ) signal : Fire ( - 20 ) signal : Fire ( - 5 ) signal : Fire ( 15 )","title":"Promise([predicate: (...) -&gt; boolean])"},{"location":"util/signal/#connectfn-void","text":"Connects a function to the signal and returns a connection object. 1 2 3 4 5 6 7 8 9 local connection = signal : Connect ( function ( arg1 , arg2 , arg3 ) ... end ) -- Connections can be disconnected connection : Disconnect () -- Check if a connection is still connected if connection . Connected then ... end","title":"Connect(fn: (...) -&gt; void)"},{"location":"util/signal/#disconnectall","text":"1 2 -- Disconnects all connections to the signal signal : DisconnectAll ()","title":"DisconnectAll()"},{"location":"util/signal/#destroy","text":"1 2 -- Destroys the signal signal : Destroy ()","title":"Destroy()"},{"location":"util/streamable/","text":"Streamables allow developers to observe the existence of an instance. This is very useful for watching parts within a model in a game that has StreamingEnabled on. Streamables allow clean setup and teardown of streamed instances. In just about all cases, streamables should be attached to a model somewhere within the workspace and observe a BasePart child within the model. Streamables can be paired with Components. If a component is attached to a model and the component needs to access the model's children, a streamable can guarantee safe access to those children. When using a streamable within a component, be sure to pass the streamable to the component's janitor for automatic cleanup. Check out Roblox's Content Streaming documentation for more information on how content is streamed into and out of games during runtime. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 local Streamable = require ( Knit . Util . Streamable ) local streamable = Streamable . new ( workspace . MyModel , \"SomePart\" ) -- Expects \"SomePart\" to be a direct child of MyModel streamable : Observe ( function ( part , janitor ) -- This function is called every time 'SomePart' comes into existence. -- The 'janitor' is cleaned up when 'SomePart' is removed from existence. print ( part . Name .. \" exists\" ) janitor : Add ( function () print ( part . Name .. \" no longer exists\" ) end ) end ) -- Multiple functions can be attached to the streamable: streamable : Observe ( function ( part , janitor ) print ( \"Another one!\" ) end ) -- Streamables should be destroyed when no longer needed: streamable : Destroy () -- Streamables are often passed to janitors instead of explicitly calling Destroy: someJanitor : Add ( streamable )","title":"Streamable"},{"location":"util/streamableutil/","text":"StreamableUtil offers extra functionality for Streamables. For instance, StreamableUtil.Compound can be used to observe multiple streamables, and thus guarantee access to all instances referenced. 1 2 3 4 5 6 7 8 9 10 11 -- Compound Streamables: local s1 = Streamable . new ( someModel , \"SomeChild\" ) local s2 = Streamable . new ( anotherModel , \"AnotherChild\" ) StreamableUtil . Compound ({ Stream1 = s1 , Stream2 = s2 }, function ( streamables , janitor ) local someChild = streamables . Stream1 . Instance local anotherChild = streamables . Stream2 . Instance janitor : Add ( function () -- Cleanup (will be called if ANY streamables are cleaned up) end ) end )","title":"StreamableUtil"},{"location":"util/tableutil/","text":"The TableUtil module provides extra functions to deal with tables. Copy \u00b6 TableUtil.Copy(tbl: table): table Performs a deep copy of the given table. In other words, all nested tables will also get copied. Use Copy if the entire table must be copied over. Otherwise, use CopyShallow . 1 2 3 4 5 local tbl = { \"a\" , \"b\" , \"c\" , { \"d\" , \"e\" , \"f\" }} local tblCopy = TableUtil . Copy ( tbl ) print ( tblCopy ) --> {\"a\", \"b\", \"c\", {\"d\", \"e\", \"f\"}} print ( tblCopy [ 4 ] == tbl [ 4 ]) --> false Cyclical Tables The Copy function does not handle cyclical tables. Passing a table with cyclical references to Copy will result in a stack-overflow. Copy can be used with arrays and dictionaries. CopyShallow \u00b6 TableUtil.CopyShallow(tbl: table): table Performs a shallow copy of the given table. In other words, all nested tables will not be copied, but only re-referenced. Thus, a nested table in both the original and the copy will be the same. 1 2 3 4 5 local tbl = { \"a\" , \"b\" , \"c\" , { \"d\" , \"e\" , \"f\" }} local tblCopy = TableUtil . CopyShallow ( tbl ) print ( tblCopy ) --> {\"a\", \"b\", \"c\", {\"d\", \"e\", \"f\"}} print ( tblCopy [ 4 ] == tbl [ 4 ]) --> true CopyShallow can be used with arrays and dictionaries. Sync \u00b6 TableUtil.Sync(tbl: table, template: table): table Synchronizes the tbl table based on template table. If tbl is missing something from template , it is added. If tbl has something that template does not, it is removed. If tbl has a different data type than the item in template , overwrite with the template value instead. 1 2 3 4 5 6 7 8 9 10 local template = { kills = 0 ; deaths = 0 ; points = 0 ; } local data = { kills = 10 ; deaths = \"test\" ; xp = 20 } local syncData = TableUtil . Sync ( data , template ) print ( syncData ) --> {kills = 10, deaths = 0, points = 0} From the above example, Sync did the following: - Kept kills the same because it already exists and is of the same data type. - Overwrote deaths to the template value because of the mismatched data type. - Added points because it was missing. - Removed xp because it was not present in the template. Cyclical Tables Although not shown in the above example, Sync will properly handle nested tables; however, it will not handle cyclical tables. Cyclical tables given to Sync will throw a stack-overflow error. Sync can be used with arrays and dictionaries. FastRemove \u00b6 TableUtil.FastRemove(tbl: table, index: number): void Quickly removes the index from the table in O(1) time. This is done by simply swapping the last value in the table with the given index, and then trimming off the last index. Using FastRemove is beneficial where data in large arrays need to be removed quickly and ordering is where the ordering of items in said array are not important. This function will mutate the given table. 1 2 3 local tbl = { \"Hello\" , \"world\" , \"how\" , \"are\" , \"you\" } TableUtil . FastRemove ( tbl , 2 ) -- Remove index 2 (\"world\") from the table print ( tbl ) --> {\"Hello\", \"you\", \"how\", \"are\"} Table Order Table order is not preserved when using FastRemove . If the ordering of the table must not change, use table.remove() instead. FastRemove can only be used with arrays. FastRemoveFirstValue \u00b6 TableUtil.FastRemoveFirstValue(tbl: table, value: any): (boolean, number | nil) Quickly removes the first index in the table that matches value . If the value is found, this function will return both true and the index at which the value was found. If not found, this function will return true and nil for the index. 1 2 3 local tbl = { \"Hello\" , \"world\" , \"how\" , \"are\" , \"you\" } local removed , index = TableUtil . FastRemove ( tbl , \"are\" ) print ( tbl , removed , index ) --> {\"Hello\", \"world\", \"how\", \"you\"}, true, 4 FastRemoveFirstValue can only be used with arrays. Map \u00b6 TableUtil.Map(tbl: table, callback: (value: any) -> any): table Creates a new table mapped from the original, given the callback predicate. Mapping tables makes it easy to transform large sets of data into a different format. For instance, if there was a table with a bunch of items representing people's first and last name, Map could be used to turn this into a simple combined list of first and last names: 1 2 3 4 5 6 7 8 9 10 11 12 local people = { { FirstName = \"John\" , LastName = \"Doe\" }, { FirstName = \"Jane\" , LastName = \"Doe\" }, { FirstName = \"Jack\" , LastName = \"Smith\" }, { FirstName = \"Jill\" , LastName = \"Smith\" }, } local names = TableUtil . Map ( people , function ( person ) return person . FirstName .. \" \" .. person . LastName end ) print ( names ) --> {\"John Doe\", \"Jane Doe\", \"Jack Smith\", \"Jill Smith\"} Bonus: To add a new FullName field, the function could be rewritten as such: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 people = TableUtil . Map ( people , function ( person ) -- Make a copy of person instead of modifying the original person = TableUtil . Copy ( person ) person . FullName = person . FirstName .. \" \" .. person . LastName return person end ) print ( people ) --[[ { {FirstName = \"John\", LastName = \"Doe\", FullName = \"John Doe\"}, {FirstName = \"Jane\", LastName = \"Doe\", FullName = \"Jane Doe\"}, {FirstName = \"Jack\", LastName = \"Smith\", FullName = \"Jack Smith\"}, {FirstName = \"Jill\", LastName = \"Smith\", FullName = \"Jill Smith\"}, } ]] Map can be used with both arrays and dictionaries. Filter \u00b6 TableUtil.Filter(tbl: table, callback: (value: any) -> boolean): table Creates a new table only containing values that the callback predicate has determined should remain from the original table. 1 2 3 4 5 6 local scores = { 10 , 20 , 5 , 3 , 6 , 23 , 15 , 40 , 31 } local scoresAboveTwenty = TableUtil . Filter ( scores , function ( value ) return value > 20 end ) print ( scores ) --> {23, 40, 31} Filter can be used with both arrays and dictionaries. Reduce \u00b6 TableUtil.Reduce(tbl: table, callback: (acc: any, val: any) -> number [, init: any]): any Reduces the contents of a table to a certain value. If the init value is not specified, it defaults to the first value in the table. 1 2 3 4 5 6 7 local scores = { 10 , 20 , 30 } local totalScore = TableUtil . Reduce ( scores , function ( accumulator , value ) return accumulator + value end ) print ( totalScore ) --> 60 An initial value can also be set as the last argument of Reduce : 1 2 3 4 5 6 7 8 local initialValue = 40 local scores = { 10 , 20 , 30 } local totalScore = TableUtil . Reduce ( scores , function ( accumulator , value ) return accumulator + value end , initialValue ) print ( totalScore ) --> 100 The Reduce function is not limited to numbers. Here's an example of a very inefficient string builder: 1 2 3 4 5 6 local values = { \"A\" , \"B\" , \"C\" } local str = TableUtil . Reduce ( values , function ( accumulator , value ) return accumulator .. value end ) print ( str ) --> \"ABC\" Functions could also be combined using a reducer: 1 2 3 4 5 6 7 8 9 10 11 12 local function Square ( x ) return x * x end local function Double ( x ) return x * 2 end local Func = TableUtil . Reduce ({ Square , Double }, function ( a , b ) return function ( x ) return a ( b ( x )) end end ) -- Func == Square(Double(x)) local result = Func ( 10 ) print ( result ) --> 400 Reduce can be used with both arrays and dictionaries. Assign \u00b6 TableUtil.Assign(target: table, ...sources: table): table Assigns the values of sources to a copy of target . This is useful for composing an object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local function Driver () return { Drive = function ( self ) self . Speed = 10 end ; } end local function Teleporter () return { Teleport = function ( self , pos ) self . Position = pos end ; } end local function CreateCar () local state = { Speed = 0 ; Position = Vector3 . new (); } -- Assign the Driver and Teleporter components to the car: return TableUtil . Assign ( state , Driver (), Teleporter ()) end local car = CreateCar () car : Drive () car : Teleport ( Vector3 . new ( 0 , 10 , 0 )) Assign can be used with both arrays and dictionaries, but is most commonly used on dictionaries. Extend \u00b6 TableUtil.Extend(tbl: table, extension: table): table Extends an array with another. This essentially appends the entirety of the extension table at the end of tbl . 1 2 3 4 5 6 local data = { 10 , 20 , 30 } local newData = { 40 , 50 , 60 } local combinedData = TableUtil . Extend ( data , newData ) print ( combinedData ) --> {10, 20, 30, 40, 50, 60} Shallow Copy The movement of extension to tbl is a shallow copy. Extend can only be used with arrays. Reverse \u00b6 TableUtil.Reverse(tbl: table): table Creates a reversed version of the table. 1 2 3 4 local data = { 1 , 2 , 3 , 4 , 5 } local reversed = TableUtil . Reverse ( data ) print ( reversed ) --> {5, 4, 3, 2, 1} Reverse can only be used with arrays. Shuffle \u00b6 TableUtil.Shuffle(tbl: table [, rng: Random]): table Creates a shallow copy of the given table and shuffles it using the Fisher-Yates shuffle algorithm. If desired, a Random object can be passed as a second argument to override the default RNG in TableUtil. 1 2 3 4 5 local music = { \"Song1\" , \"Song2\" , \"Song3\" , \"Song4\" , \"Song5\" } local shuffledMusic = TableUtil . Shuffle ( music ) print ( shuffledMusic ) --> e.g. {\"Song4\", \"Song5\", \"Song2\", \"Song3\", \"Song1\"} Shuffle can only be used with arrays. Sample \u00b6 TableUtil.Sample(tbl: table, size: number [, rng: Random]): table Returns a random sample of the given array. The sample size is determined by the size argument. 1 2 3 4 local names = { \"John\" , \"Mary\" , \"Ron\" , \"Julie\" , \"Sam\" } local sample = TableUtil . Sample ( names , 3 ) print ( sample ) --> e.g. {\"Julie\", \"John\", \"Sam\"} Sample can only be used with arrays. Flat \u00b6 TableUtil.Flat(tbl: table [, maxDepth: number = 1]): table Flattens out an array that might have multiple nested arrays. The maxDepth optional parameter controls how deep the function can go into nested arrays. 1 2 3 4 5 local tbl = { 1 , 2 , { 3 , 4 , { 5 , 6 }}, { 7 , { 8 , 9 }}} local flat = TableUtil . Flat ( tbl , 2 ) print ( flat ) --> {1, 2, 3, 4, 5, 6, 7, 8, 9} Flat can only be used with arrays. FlatMap \u00b6 TableUtil.FlatMap(tbl: callback: (value: any) -> table): table For each value in a table, FlatMap will call Map on the item and then Flat (with a max depth of 1) on whatever was returned from Map . 1 2 3 4 5 6 7 8 9 10 11 12 local tbl = { \"Flat map\" , \"is\" , \"really cool to\" , \"use\" } local flatMap = TableUtil . FlatMap ( tbl , function ( words ) return words : split ( \" \" ) end ) print ( flatMap ) --> {\"Flat\", \"map\", \"is\", \"really\", \"cool\", \"to\", \"use\"} FlatMap can only be used with arrays. Keys \u00b6 TableUtil.Keys(tbl: table): table Returns an array of all keys in the table. 1 2 3 4 5 local tbl = { Hello = 0 , World = 1 } local keys = TableUtil . Keys ( tbl ) print ( keys ) --> {\"Hello\", \"World\"} No Ordering Lua dictionaries have no set ordering for keys, so the order of keys in the returned table may be different per call. If ordering is important, use table.sort() on the returned array of keys. Keys can be used with both arrays and dictionaries, but only makes sense to use with dictionaries. Find \u00b6 TableUtil.Find(tbl: table, callback: (value: any) -> boolean): (any, number | nil) Finds a value in the given table using the callback predicate. If found, the value and the index are returned. If not found, nil is returned. 1 2 3 4 5 6 7 8 9 10 11 local tbl = { { Name = \"John\" , Score = 10 }, { Name = \"Jane\" , Score = 20 }, { Name = \"Jerry\" , Score = 30 } } local person , index = TableUtil . Find ( tbl , function ( p ) return p . Name == \"Jane\" end ) print ( person , index ) --> \"Jane\", 2 Not the same as table.find() This is not the same as table.find() , which returns the index of the first matched value. Using Find allows for more complex searches, since the condition can be computed more than simply an equality check. Find can be used with both arrays and dictionaries. Every \u00b6 TableUtil.Every(tbl: table, callback: (value: any) -> boolean): boolean Returns true if every value in the table returns true against the callback predicate. 1 2 3 4 5 6 7 8 9 10 11 12 local numbers = { 7 , 20 , 30 } local allAboveFive = TableUtil . Every ( numbers , function ( num ) return num > 5 end ) local allAboveTen = TableUtil . Every ( numbers , function ( num ) return num > 10 end ) print ( \"AllAboveFive\" , allAboveFive ) --> AllAboveFive, true print ( \"AllAboveTen\" , allAboveTen ) --> AllAboveTen, false Every can be used with both arrays and dictionaries. Some \u00b6 TableUtil.Some(tbl: table, callback: (value: any) -> boolean): boolean Returns true if at least one value in the table returns true against the callback predicate. 1 2 3 4 5 6 7 8 9 10 11 12 local numbers = { 10 , 50 , 100 } local someAboveSeventy = TableUtil . Some ( numbers , function ( num ) return num > 70 end ) local someBelowFive = TableUtil . Every ( numbers , function ( num ) return num < 5 end ) print ( \"SomeAboveSeventy\" , someAboveSeventy ) --> SomeAboveSeventy, true print ( \"SomeBelowFive\" , someBelowFive ) --> SomeBelowFive, false Some can be used with both arrays and dictionaries. Truncate \u00b6 TableUtil.Truncate(tbl: table, length: number): table Truncates a table to the specified length. 1 2 3 4 local t1 = { 10 , 20 , 30 , 40 , 50 } local t2 = TableUtil . Truncate ( t1 , 3 ) print ( t2 ) --> {10, 20, 30} Zip \u00b6 TableUtil.Zip(...table): Iterator Returns an iterator that can be used to iterate through multiple different arrays or dictionaries. Any overlapping indices between all given tables will be included in the iteration. 1 2 3 4 5 6 7 8 9 local a = { 4 , 5 , 6 } local b = { 9 , 8 , 7 } for i , values in TableUtil . Zip ( a , b ) do print ( i , values ) end --> 1 {4, 9} --> 2 {5, 8} --> 3 {6, 7} 1 2 3 4 5 6 7 8 9 10 local a = { X = 10 , Y = 20 , Z = 30 } local b = { X = 40 , Y = 50 , Z = 60 } local c = { X = 70 , Y = 80 , Z = 90 } for k , values in TableUtil . Zip ( a , b , c ) do print ( k , values ) end --> X {10, 40, 70} --> Y {20, 50, 80} --> Z {30, 60, 90} IsEmpty \u00b6 TableUtil.IsEmpty(tbl: table): boolean Returns true if the table is empty. The implementation for this is simply checking against the condition: next(tbl) == nil . 1 2 3 4 5 6 7 local t1 = {} local t2 = { 32 } local t3 = { num = 10 } print ( \"T1 empty\" , TableUtil . IsEmpty ( t1 )) --> T1 empty, true print ( \"T2 empty\" , TableUtil . IsEmpty ( t2 )) --> T2 empty, false print ( \"T3 empty\" , TableUtil . IsEmpty ( t3 )) --> T3 empty, false IsEmpty can be used with both arrays and dictionaries. EncodeJSON \u00b6 TableUtil.EncodeJSON(tbl: table): string Transforms the given table into a JSON string. An error will be thrown if the table cannot be transformed. Internally, this is just a proxy for HttpService:JSONEncode() . 1 2 3 4 5 6 7 8 local tbl = { xp = 100 ; money = 500 ; } local json = TableUtil . EncodeJSON ( tbl ) print ( json ) --> {\"xp\": 100, \"money\": 500} DecodeJSON \u00b6 TableUtil.DecodeJSON(json: string): table Transforms the given JSON string into a Lua table. An error will be thrown if the JSON string cannot be transformed. Internally, this is just a proxy for HttpService:JSONDecode() . 1 2 3 4 5 local json = [[{\"xp\": 100, \"money\": 500}]] local tbl = TableUtil . DecodeJSON ( json ) print ( tbl ) --> {xp = 100, money = 500}","title":"TableUtil"},{"location":"util/tableutil/#copy","text":"TableUtil.Copy(tbl: table): table Performs a deep copy of the given table. In other words, all nested tables will also get copied. Use Copy if the entire table must be copied over. Otherwise, use CopyShallow . 1 2 3 4 5 local tbl = { \"a\" , \"b\" , \"c\" , { \"d\" , \"e\" , \"f\" }} local tblCopy = TableUtil . Copy ( tbl ) print ( tblCopy ) --> {\"a\", \"b\", \"c\", {\"d\", \"e\", \"f\"}} print ( tblCopy [ 4 ] == tbl [ 4 ]) --> false Cyclical Tables The Copy function does not handle cyclical tables. Passing a table with cyclical references to Copy will result in a stack-overflow. Copy can be used with arrays and dictionaries.","title":"Copy"},{"location":"util/tableutil/#copyshallow","text":"TableUtil.CopyShallow(tbl: table): table Performs a shallow copy of the given table. In other words, all nested tables will not be copied, but only re-referenced. Thus, a nested table in both the original and the copy will be the same. 1 2 3 4 5 local tbl = { \"a\" , \"b\" , \"c\" , { \"d\" , \"e\" , \"f\" }} local tblCopy = TableUtil . CopyShallow ( tbl ) print ( tblCopy ) --> {\"a\", \"b\", \"c\", {\"d\", \"e\", \"f\"}} print ( tblCopy [ 4 ] == tbl [ 4 ]) --> true CopyShallow can be used with arrays and dictionaries.","title":"CopyShallow"},{"location":"util/tableutil/#sync","text":"TableUtil.Sync(tbl: table, template: table): table Synchronizes the tbl table based on template table. If tbl is missing something from template , it is added. If tbl has something that template does not, it is removed. If tbl has a different data type than the item in template , overwrite with the template value instead. 1 2 3 4 5 6 7 8 9 10 local template = { kills = 0 ; deaths = 0 ; points = 0 ; } local data = { kills = 10 ; deaths = \"test\" ; xp = 20 } local syncData = TableUtil . Sync ( data , template ) print ( syncData ) --> {kills = 10, deaths = 0, points = 0} From the above example, Sync did the following: - Kept kills the same because it already exists and is of the same data type. - Overwrote deaths to the template value because of the mismatched data type. - Added points because it was missing. - Removed xp because it was not present in the template. Cyclical Tables Although not shown in the above example, Sync will properly handle nested tables; however, it will not handle cyclical tables. Cyclical tables given to Sync will throw a stack-overflow error. Sync can be used with arrays and dictionaries.","title":"Sync"},{"location":"util/tableutil/#fastremove","text":"TableUtil.FastRemove(tbl: table, index: number): void Quickly removes the index from the table in O(1) time. This is done by simply swapping the last value in the table with the given index, and then trimming off the last index. Using FastRemove is beneficial where data in large arrays need to be removed quickly and ordering is where the ordering of items in said array are not important. This function will mutate the given table. 1 2 3 local tbl = { \"Hello\" , \"world\" , \"how\" , \"are\" , \"you\" } TableUtil . FastRemove ( tbl , 2 ) -- Remove index 2 (\"world\") from the table print ( tbl ) --> {\"Hello\", \"you\", \"how\", \"are\"} Table Order Table order is not preserved when using FastRemove . If the ordering of the table must not change, use table.remove() instead. FastRemove can only be used with arrays.","title":"FastRemove"},{"location":"util/tableutil/#fastremovefirstvalue","text":"TableUtil.FastRemoveFirstValue(tbl: table, value: any): (boolean, number | nil) Quickly removes the first index in the table that matches value . If the value is found, this function will return both true and the index at which the value was found. If not found, this function will return true and nil for the index. 1 2 3 local tbl = { \"Hello\" , \"world\" , \"how\" , \"are\" , \"you\" } local removed , index = TableUtil . FastRemove ( tbl , \"are\" ) print ( tbl , removed , index ) --> {\"Hello\", \"world\", \"how\", \"you\"}, true, 4 FastRemoveFirstValue can only be used with arrays.","title":"FastRemoveFirstValue"},{"location":"util/tableutil/#map","text":"TableUtil.Map(tbl: table, callback: (value: any) -> any): table Creates a new table mapped from the original, given the callback predicate. Mapping tables makes it easy to transform large sets of data into a different format. For instance, if there was a table with a bunch of items representing people's first and last name, Map could be used to turn this into a simple combined list of first and last names: 1 2 3 4 5 6 7 8 9 10 11 12 local people = { { FirstName = \"John\" , LastName = \"Doe\" }, { FirstName = \"Jane\" , LastName = \"Doe\" }, { FirstName = \"Jack\" , LastName = \"Smith\" }, { FirstName = \"Jill\" , LastName = \"Smith\" }, } local names = TableUtil . Map ( people , function ( person ) return person . FirstName .. \" \" .. person . LastName end ) print ( names ) --> {\"John Doe\", \"Jane Doe\", \"Jack Smith\", \"Jill Smith\"} Bonus: To add a new FullName field, the function could be rewritten as such: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 people = TableUtil . Map ( people , function ( person ) -- Make a copy of person instead of modifying the original person = TableUtil . Copy ( person ) person . FullName = person . FirstName .. \" \" .. person . LastName return person end ) print ( people ) --[[ { {FirstName = \"John\", LastName = \"Doe\", FullName = \"John Doe\"}, {FirstName = \"Jane\", LastName = \"Doe\", FullName = \"Jane Doe\"}, {FirstName = \"Jack\", LastName = \"Smith\", FullName = \"Jack Smith\"}, {FirstName = \"Jill\", LastName = \"Smith\", FullName = \"Jill Smith\"}, } ]] Map can be used with both arrays and dictionaries.","title":"Map"},{"location":"util/tableutil/#filter","text":"TableUtil.Filter(tbl: table, callback: (value: any) -> boolean): table Creates a new table only containing values that the callback predicate has determined should remain from the original table. 1 2 3 4 5 6 local scores = { 10 , 20 , 5 , 3 , 6 , 23 , 15 , 40 , 31 } local scoresAboveTwenty = TableUtil . Filter ( scores , function ( value ) return value > 20 end ) print ( scores ) --> {23, 40, 31} Filter can be used with both arrays and dictionaries.","title":"Filter"},{"location":"util/tableutil/#reduce","text":"TableUtil.Reduce(tbl: table, callback: (acc: any, val: any) -> number [, init: any]): any Reduces the contents of a table to a certain value. If the init value is not specified, it defaults to the first value in the table. 1 2 3 4 5 6 7 local scores = { 10 , 20 , 30 } local totalScore = TableUtil . Reduce ( scores , function ( accumulator , value ) return accumulator + value end ) print ( totalScore ) --> 60 An initial value can also be set as the last argument of Reduce : 1 2 3 4 5 6 7 8 local initialValue = 40 local scores = { 10 , 20 , 30 } local totalScore = TableUtil . Reduce ( scores , function ( accumulator , value ) return accumulator + value end , initialValue ) print ( totalScore ) --> 100 The Reduce function is not limited to numbers. Here's an example of a very inefficient string builder: 1 2 3 4 5 6 local values = { \"A\" , \"B\" , \"C\" } local str = TableUtil . Reduce ( values , function ( accumulator , value ) return accumulator .. value end ) print ( str ) --> \"ABC\" Functions could also be combined using a reducer: 1 2 3 4 5 6 7 8 9 10 11 12 local function Square ( x ) return x * x end local function Double ( x ) return x * 2 end local Func = TableUtil . Reduce ({ Square , Double }, function ( a , b ) return function ( x ) return a ( b ( x )) end end ) -- Func == Square(Double(x)) local result = Func ( 10 ) print ( result ) --> 400 Reduce can be used with both arrays and dictionaries.","title":"Reduce"},{"location":"util/tableutil/#assign","text":"TableUtil.Assign(target: table, ...sources: table): table Assigns the values of sources to a copy of target . This is useful for composing an object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 local function Driver () return { Drive = function ( self ) self . Speed = 10 end ; } end local function Teleporter () return { Teleport = function ( self , pos ) self . Position = pos end ; } end local function CreateCar () local state = { Speed = 0 ; Position = Vector3 . new (); } -- Assign the Driver and Teleporter components to the car: return TableUtil . Assign ( state , Driver (), Teleporter ()) end local car = CreateCar () car : Drive () car : Teleport ( Vector3 . new ( 0 , 10 , 0 )) Assign can be used with both arrays and dictionaries, but is most commonly used on dictionaries.","title":"Assign"},{"location":"util/tableutil/#extend","text":"TableUtil.Extend(tbl: table, extension: table): table Extends an array with another. This essentially appends the entirety of the extension table at the end of tbl . 1 2 3 4 5 6 local data = { 10 , 20 , 30 } local newData = { 40 , 50 , 60 } local combinedData = TableUtil . Extend ( data , newData ) print ( combinedData ) --> {10, 20, 30, 40, 50, 60} Shallow Copy The movement of extension to tbl is a shallow copy. Extend can only be used with arrays.","title":"Extend"},{"location":"util/tableutil/#reverse","text":"TableUtil.Reverse(tbl: table): table Creates a reversed version of the table. 1 2 3 4 local data = { 1 , 2 , 3 , 4 , 5 } local reversed = TableUtil . Reverse ( data ) print ( reversed ) --> {5, 4, 3, 2, 1} Reverse can only be used with arrays.","title":"Reverse"},{"location":"util/tableutil/#shuffle","text":"TableUtil.Shuffle(tbl: table [, rng: Random]): table Creates a shallow copy of the given table and shuffles it using the Fisher-Yates shuffle algorithm. If desired, a Random object can be passed as a second argument to override the default RNG in TableUtil. 1 2 3 4 5 local music = { \"Song1\" , \"Song2\" , \"Song3\" , \"Song4\" , \"Song5\" } local shuffledMusic = TableUtil . Shuffle ( music ) print ( shuffledMusic ) --> e.g. {\"Song4\", \"Song5\", \"Song2\", \"Song3\", \"Song1\"} Shuffle can only be used with arrays.","title":"Shuffle"},{"location":"util/tableutil/#sample","text":"TableUtil.Sample(tbl: table, size: number [, rng: Random]): table Returns a random sample of the given array. The sample size is determined by the size argument. 1 2 3 4 local names = { \"John\" , \"Mary\" , \"Ron\" , \"Julie\" , \"Sam\" } local sample = TableUtil . Sample ( names , 3 ) print ( sample ) --> e.g. {\"Julie\", \"John\", \"Sam\"} Sample can only be used with arrays.","title":"Sample"},{"location":"util/tableutil/#flat","text":"TableUtil.Flat(tbl: table [, maxDepth: number = 1]): table Flattens out an array that might have multiple nested arrays. The maxDepth optional parameter controls how deep the function can go into nested arrays. 1 2 3 4 5 local tbl = { 1 , 2 , { 3 , 4 , { 5 , 6 }}, { 7 , { 8 , 9 }}} local flat = TableUtil . Flat ( tbl , 2 ) print ( flat ) --> {1, 2, 3, 4, 5, 6, 7, 8, 9} Flat can only be used with arrays.","title":"Flat"},{"location":"util/tableutil/#flatmap","text":"TableUtil.FlatMap(tbl: callback: (value: any) -> table): table For each value in a table, FlatMap will call Map on the item and then Flat (with a max depth of 1) on whatever was returned from Map . 1 2 3 4 5 6 7 8 9 10 11 12 local tbl = { \"Flat map\" , \"is\" , \"really cool to\" , \"use\" } local flatMap = TableUtil . FlatMap ( tbl , function ( words ) return words : split ( \" \" ) end ) print ( flatMap ) --> {\"Flat\", \"map\", \"is\", \"really\", \"cool\", \"to\", \"use\"} FlatMap can only be used with arrays.","title":"FlatMap"},{"location":"util/tableutil/#keys","text":"TableUtil.Keys(tbl: table): table Returns an array of all keys in the table. 1 2 3 4 5 local tbl = { Hello = 0 , World = 1 } local keys = TableUtil . Keys ( tbl ) print ( keys ) --> {\"Hello\", \"World\"} No Ordering Lua dictionaries have no set ordering for keys, so the order of keys in the returned table may be different per call. If ordering is important, use table.sort() on the returned array of keys. Keys can be used with both arrays and dictionaries, but only makes sense to use with dictionaries.","title":"Keys"},{"location":"util/tableutil/#find","text":"TableUtil.Find(tbl: table, callback: (value: any) -> boolean): (any, number | nil) Finds a value in the given table using the callback predicate. If found, the value and the index are returned. If not found, nil is returned. 1 2 3 4 5 6 7 8 9 10 11 local tbl = { { Name = \"John\" , Score = 10 }, { Name = \"Jane\" , Score = 20 }, { Name = \"Jerry\" , Score = 30 } } local person , index = TableUtil . Find ( tbl , function ( p ) return p . Name == \"Jane\" end ) print ( person , index ) --> \"Jane\", 2 Not the same as table.find() This is not the same as table.find() , which returns the index of the first matched value. Using Find allows for more complex searches, since the condition can be computed more than simply an equality check. Find can be used with both arrays and dictionaries.","title":"Find"},{"location":"util/tableutil/#every","text":"TableUtil.Every(tbl: table, callback: (value: any) -> boolean): boolean Returns true if every value in the table returns true against the callback predicate. 1 2 3 4 5 6 7 8 9 10 11 12 local numbers = { 7 , 20 , 30 } local allAboveFive = TableUtil . Every ( numbers , function ( num ) return num > 5 end ) local allAboveTen = TableUtil . Every ( numbers , function ( num ) return num > 10 end ) print ( \"AllAboveFive\" , allAboveFive ) --> AllAboveFive, true print ( \"AllAboveTen\" , allAboveTen ) --> AllAboveTen, false Every can be used with both arrays and dictionaries.","title":"Every"},{"location":"util/tableutil/#some","text":"TableUtil.Some(tbl: table, callback: (value: any) -> boolean): boolean Returns true if at least one value in the table returns true against the callback predicate. 1 2 3 4 5 6 7 8 9 10 11 12 local numbers = { 10 , 50 , 100 } local someAboveSeventy = TableUtil . Some ( numbers , function ( num ) return num > 70 end ) local someBelowFive = TableUtil . Every ( numbers , function ( num ) return num < 5 end ) print ( \"SomeAboveSeventy\" , someAboveSeventy ) --> SomeAboveSeventy, true print ( \"SomeBelowFive\" , someBelowFive ) --> SomeBelowFive, false Some can be used with both arrays and dictionaries.","title":"Some"},{"location":"util/tableutil/#truncate","text":"TableUtil.Truncate(tbl: table, length: number): table Truncates a table to the specified length. 1 2 3 4 local t1 = { 10 , 20 , 30 , 40 , 50 } local t2 = TableUtil . Truncate ( t1 , 3 ) print ( t2 ) --> {10, 20, 30}","title":"Truncate"},{"location":"util/tableutil/#zip","text":"TableUtil.Zip(...table): Iterator Returns an iterator that can be used to iterate through multiple different arrays or dictionaries. Any overlapping indices between all given tables will be included in the iteration. 1 2 3 4 5 6 7 8 9 local a = { 4 , 5 , 6 } local b = { 9 , 8 , 7 } for i , values in TableUtil . Zip ( a , b ) do print ( i , values ) end --> 1 {4, 9} --> 2 {5, 8} --> 3 {6, 7} 1 2 3 4 5 6 7 8 9 10 local a = { X = 10 , Y = 20 , Z = 30 } local b = { X = 40 , Y = 50 , Z = 60 } local c = { X = 70 , Y = 80 , Z = 90 } for k , values in TableUtil . Zip ( a , b , c ) do print ( k , values ) end --> X {10, 40, 70} --> Y {20, 50, 80} --> Z {30, 60, 90}","title":"Zip"},{"location":"util/tableutil/#isempty","text":"TableUtil.IsEmpty(tbl: table): boolean Returns true if the table is empty. The implementation for this is simply checking against the condition: next(tbl) == nil . 1 2 3 4 5 6 7 local t1 = {} local t2 = { 32 } local t3 = { num = 10 } print ( \"T1 empty\" , TableUtil . IsEmpty ( t1 )) --> T1 empty, true print ( \"T2 empty\" , TableUtil . IsEmpty ( t2 )) --> T2 empty, false print ( \"T3 empty\" , TableUtil . IsEmpty ( t3 )) --> T3 empty, false IsEmpty can be used with both arrays and dictionaries.","title":"IsEmpty"},{"location":"util/tableutil/#encodejson","text":"TableUtil.EncodeJSON(tbl: table): string Transforms the given table into a JSON string. An error will be thrown if the table cannot be transformed. Internally, this is just a proxy for HttpService:JSONEncode() . 1 2 3 4 5 6 7 8 local tbl = { xp = 100 ; money = 500 ; } local json = TableUtil . EncodeJSON ( tbl ) print ( json ) --> {\"xp\": 100, \"money\": 500}","title":"EncodeJSON"},{"location":"util/tableutil/#decodejson","text":"TableUtil.DecodeJSON(json: string): table Transforms the given JSON string into a Lua table. An error will be thrown if the JSON string cannot be transformed. Internally, this is just a proxy for HttpService:JSONDecode() . 1 2 3 4 5 local json = [[{\"xp\": 100, \"money\": 500}]] local tbl = TableUtil . DecodeJSON ( json ) print ( tbl ) --> {xp = 100, money = 500}","title":"DecodeJSON"},{"location":"util/timer/","text":"The Timer class allows for firing tasks at given intervals. An example could be a periodic check to see if a car is flipped upside down. 1 2 3 4 5 6 7 8 9 local Timer = require ( Knit . Util . Timer ) local timer = Timer . new ( 1 ) timer . Tick : Connect ( function () print ( \"Tock\" ) end ) timer : Start () Constructor \u00b6 1 timer = Timer . new ( interval : number [, janitor : Janitor ]) Fields \u00b6 1 2 3 4 5 -- Seconds between ticks: timer . Interval : number -- Signal fired at each interval: timer . Tick : Signal Methods \u00b6 1 2 3 4 5 6 7 8 9 10 11 -- Start the timer: timer : Start () -- Same as Start, but fires the 'Tick' signal immediately: timer : StartNow () -- Stop the timer: timer : Stop () -- Clean up: timer : Destroy ()","title":"Timer"},{"location":"util/timer/#constructor","text":"1 timer = Timer . new ( interval : number [, janitor : Janitor ])","title":"Constructor"},{"location":"util/timer/#fields","text":"1 2 3 4 5 -- Seconds between ticks: timer . Interval : number -- Signal fired at each interval: timer . Tick : Signal","title":"Fields"},{"location":"util/timer/#methods","text":"1 2 3 4 5 6 7 8 9 10 11 -- Start the timer: timer : Start () -- Same as Start, but fires the 'Tick' signal immediately: timer : StartNow () -- Stop the timer: timer : Stop () -- Clean up: timer : Destroy ()","title":"Methods"}]}